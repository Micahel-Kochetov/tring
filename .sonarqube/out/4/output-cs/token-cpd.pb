—¸
C:\Users\–ö–ª–∏–º–Ω—é–∫\tring\App\Assets\Plugins\Zenject\OptionalExtras\ReflectionBaking\Common\ReflectionBakingModuleEditor.cs
	namespace 	
Zenject
 
. 
ReflectionBaking "
{ 
public 

class (
ReflectionBakingModuleEditor -
{ 
readonly 
Assembly 
	_assembly #
;# $
readonly 
ModuleDefinition !
_module" )
;) *
readonly 
List 
< 
Regex 
> 
_namespaceRegexes .
;. /
MethodReference '
_zenjectTypeInfoConstructor 3
;3 4
MethodReference &
_injectableInfoConstructor 2
;2 3
MethodReference (
_injectMethodInfoConstructor 4
;4 5
MethodReference (
_injectMemberInfoConstructor 4
;4 5
MethodReference '
_constructorInfoConstructor 3
;3 4
MethodReference $
_getTypeFromHandleMethod 0
;0 1
MethodReference 
_funcConstructor (
;( )
MethodReference 
_funcPostInject '
;' (
MethodReference 
_funcMemberSetter )
;) *
MethodReference  
_preserveConstructor ,
;, -
TypeReference   !
_injectMethodInfoType   +
;  + ,
TypeReference!! !
_injectMemberInfoType!! +
;!!+ ,
TypeReference"" 
_injectableInfoType"" )
;"") *
TypeReference## 
_objectArrayType## &
;##& '
TypeReference$$  
_zenjectTypeInfoType$$ *
;$$* +(
ReflectionBakingModuleEditor&& $
(&&$ %
ModuleDefinition'' 
module'' #
,''# $
Assembly''% -
assembly''. 6
,''6 7
List''8 <
<''< =
string''= C
>''C D
namespacePatterns''E V
)''V W
{(( 	
_module)) 
=)) 
module)) 
;)) 
	_assembly** 
=** 
assembly**  
;**  !
_namespaceRegexes++ 
=++ 
namespacePatterns++  1
.++1 2
Select++2 8
(++8 9
CreateRegex++9 D
)++D E
.++E F
ToList++F L
(++L M
)++M N
;++N O
_namespaceRegexes,, 
.,, 
Add,, !
(,,! "
CreateRegex,," -
(,,- .
$str,,. 8
),,8 9
),,9 :
;,,: ;
}-- 	
public// 
static// 
int// 
WeaveAssembly// '
(//' (
ModuleDefinition00 
module00 #
,00# $
Assembly00% -
assembly00. 6
)006 7
{11 	
return22 
WeaveAssembly22  
(22  !
module22! '
,22' (
assembly22) 1
,221 2
new223 6
List227 ;
<22; <
string22< B
>22B C
(22C D
)22D E
)22E F
;22F G
}33 	
public55 
static55 
int55 
WeaveAssembly55 '
(55' (
ModuleDefinition66 
module66 #
,66# $
Assembly66% -
assembly66. 6
,666 7
List668 <
<66< =
string66= C
>66C D
namespacePatterns66E V
)66V W
{77 	
return88 
new88 (
ReflectionBakingModuleEditor88 3
(883 4
module884 :
,88: ;
assembly88< D
,88D E
namespacePatterns88F W
)88W X
.88X Y
Run88Y \
(88\ ]
)88] ^
;88^ _
}99 	
int;; 
Run;; 
(;; 
);; 
{<< 	
SaveImports== 
(== 
)== 
;== 
int?? 
numTypesEditted?? 
=??  !
$num??" #
;??# $
varAA 
allTypesAA 
=AA 
_moduleAA "
.AA" #
LookupAllTypesAA# 1
(AA1 2
)AA2 3
;AA3 4
foreachCC 
(CC 
varCC 
typeDefCC  
inCC! #
allTypesCC$ ,
)CC, -
{DD 
ifEE 
(EE 
_namespaceRegexesEE %
.EE% &
AnyEE& )
(EE) *
)EE* +
&&EE, .
!EE/ 0
_namespaceRegexesEE0 A
.EEA B
AnyEEB E
(EEE F
xEEF G
=>EEH J
xEEK L
.EEL M
IsMatchEEM T
(EET U
typeDefEEU \
.EE\ ]
FullNameEE] e
)EEe f
)EEf g
)EEg h
{FF 
continueGG 
;GG 
}HH 
varJJ 

actualTypeJJ 
=JJ  
typeDefJJ! (
.JJ( )
TryGetActualTypeJJ) 9
(JJ9 :
	_assemblyJJ: C
)JJC D
;JJD E
ifLL 
(LL 

actualTypeLL 
==LL !
nullLL" &
)LL& '
{MM 
LogNN 
.NN 
WarnNN 
(NN 
$strNN R
,NNR S
typeDefNNT [
.NN[ \
FullNameNN\ d
)NNd e
;NNe f
continueOO 
;OO 
}PP 
ifRR 
(RR 
TryEditTypeRR 
(RR  
typeDefRR  '
,RR' (

actualTypeRR) 3
)RR3 4
)RR4 5
{SS 
numTypesEdittedTT #
++TT# %
;TT% &
}UU 
}VV 
returnXX 
numTypesEdittedXX "
;XX" #
}YY 	
Regex[[ 
CreateRegex[[ 
([[ 
string[[  
regexStr[[! )
)[[) *
{\\ 	
return]] 
new]] 
Regex]] 
(]] 
regexStr]] %
,]]% &
RegexOptions]]' 3
.]]3 4
Compiled]]4 <
)]]< =
;]]= >
}^^ 	
void`` 
SaveImports`` 
(`` 
)`` 
{aa 	 
_zenjectTypeInfoTypebb  
=bb! "
_modulebb# *
.bb* +

ImportTypebb+ 5
<bb5 6
InjectTypeInfobb6 D
>bbD E
(bbE F
)bbF G
;bbG H'
_zenjectTypeInfoConstructorcc '
=cc( )
_modulecc* 1
.cc1 2
ImportMethodcc2 >
<cc> ?
InjectTypeInfocc? M
>ccM N
(ccN O
$strccO V
)ccV W
;ccW X&
_injectableInfoConstructoree &
=ee' (
_moduleee) 0
.ee0 1
ImportMethodee1 =
<ee= >
InjectableInfoee> L
>eeL M
(eeM N
$streeN U
)eeU V
;eeV W$
_getTypeFromHandleMethodgg $
=gg% &
_modulegg' .
.gg. /
ImportMethodgg/ ;
<gg; <
Typegg< @
>gg@ A
(ggA B
$strggB U
,ggU V
$numggW X
)ggX Y
;ggY Z!
_injectMethodInfoTypeii !
=ii" #
_moduleii$ +
.ii+ ,

ImportTypeii, 6
<ii6 7
InjectTypeInfoii7 E
.iiE F
InjectMethodInfoiiF V
>iiV W
(iiW X
)iiX Y
;iiY Z(
_injectMethodInfoConstructorjj (
=jj) *
_modulejj+ 2
.jj2 3
ImportMethodjj3 ?
<jj? @
InjectTypeInfojj@ N
.jjN O
InjectMethodInfojjO _
>jj_ `
(jj` a
$strjja h
)jjh i
;jji j!
_injectMemberInfoTypell !
=ll" #
_modulell$ +
.ll+ ,

ImportTypell, 6
<ll6 7
InjectTypeInfoll7 E
.llE F
InjectMemberInfollF V
>llV W
(llW X
)llX Y
;llY Z(
_injectMemberInfoConstructormm (
=mm) *
_modulemm+ 2
.mm2 3
ImportMethodmm3 ?
<mm? @
InjectTypeInfomm@ N
.mmN O
InjectMemberInfommO _
>mm_ `
(mm` a
$strmma h
)mmh i
;mmi j 
_preserveConstructoroo  
=oo! "
_moduleoo# *
.oo* +
ImportMethodoo+ 7
<oo7 8
Zenjectoo8 ?
.oo? @
Internaloo@ H
.ooH I
PreserveAttributeooI Z
>ooZ [
(oo[ \
$stroo\ c
)ooc d
;ood e'
_constructorInfoConstructorpp '
=pp( )
_modulepp* 1
.pp1 2
ImportMethodpp2 >
<pp> ?
InjectTypeInfopp? M
.ppM N!
InjectConstructorInfoppN c
>ppc d
(ppd e
$strppe l
)ppl m
;ppm n
_injectableInfoTyperr 
=rr  !
_modulerr" )
.rr) *

ImportTyperr* 4
<rr4 5
InjectableInforr5 C
>rrC D
(rrD E
)rrE F
;rrF G
_objectArrayTypett 
=tt 
_modulett &
.tt& '
Importtt' -
(tt- .
typeoftt. 4
(tt4 5
objecttt5 ;
[tt; <
]tt< =
)tt= >
)tt> ?
;tt? @
_funcConstructorvv 
=vv 
_modulevv &
.vv& '
ImportMethodvv' 3
<vv3 4
ZenFactoryMethodvv4 D
>vvD E
(vvE F
$strvvF M
,vvM N
$numvvO P
)vvP Q
;vvQ R
_funcPostInjectxx 
=xx 
_modulexx %
.xx% &
ImportMethodxx& 2
<xx2 3
ZenInjectMethodxx3 B
>xxB C
(xxC D
$strxxD K
,xxK L
$numxxM N
)xxN O
;xxO P
_funcMemberSetterzz 
=zz 
_modulezz  '
.zz' (
ImportMethodzz( 4
<zz4 5!
ZenMemberSetterMethodzz5 J
>zzJ K
(zzK L
$strzzL S
,zzS T
$numzzU V
)zzV W
;zzW X
}{{ 	
public}} 
bool}} 
TryEditType}} 
(}}  
TypeDefinition}}  .
typeDef}}/ 6
,}}6 7
Type}}8 <

actualType}}= G
)}}G H
{~~ 	
if 
( 

actualType 
. 
IsEnum !
||" $

actualType% /
./ 0
IsValueType0 ;
||< >

actualType? I
.I J
IsInterfaceJ U
||
ÄÄ 

actualType
ÄÄ 
.
ÄÄ 
HasAttribute
ÄÄ *
<
ÄÄ* +)
NoReflectionBakingAttribute
ÄÄ+ F
>
ÄÄF G
(
ÄÄG H
)
ÄÄH I
||
ÅÅ 
IsStaticClass
ÅÅ  
(
ÅÅ  !

actualType
ÅÅ! +
)
ÅÅ+ ,
||
ÅÅ- /

actualType
ÅÅ0 :
.
ÅÅ: ; 
DerivesFromOrEqual
ÅÅ; M
<
ÅÅM N
Delegate
ÅÅN V
>
ÅÅV W
(
ÅÅW X
)
ÅÅX Y
||
ÅÅZ \

actualType
ÅÅ] g
.
ÅÅg h 
DerivesFromOrEqual
ÅÅh z
<
ÅÅz {
	AttributeÅÅ{ Ñ
>ÅÅÑ Ö
(ÅÅÖ Ü
)ÅÅÜ á
)ÅÅá à
{
ÇÇ 
return
ÉÉ 
false
ÉÉ 
;
ÉÉ 
}
ÑÑ 
if
áá 
(
áá 
IsTypeProcessed
áá 
(
áá  
typeDef
áá  '
)
áá' (
)
áá( )
{
àà 
return
ââ 
false
ââ 
;
ââ 
}
ää 
try
åå 
{
çç 
var
éé 
typeInfo
éé 
=
éé $
ReflectionTypeAnalyzer
éé 5
.
éé5 6
GetReflectionInfo
éé6 G
(
ééG H

actualType
ééH R
)
ééR S
;
ééS T
var
êê 
factoryMethod
êê !
=
êê" #!
TryAddFactoryMethod
êê$ 7
(
êê7 8
typeDef
êê8 ?
,
êê? @
typeInfo
êêA I
)
êêI J
;
êêJ K
var
ëë 
genericTypeDef
ëë "
=
ëë# $1
#CreateGenericInstanceWithParameters
ëë% H
(
ëëH I
typeDef
ëëI P
)
ëëP Q
;
ëëQ R
var
íí 
fieldSetMethods
íí #
=
íí$ %
AddFieldSetters
íí& 5
(
íí5 6
typeDef
íí6 =
,
íí= >
genericTypeDef
íí? M
,
ííM N
typeInfo
ííO W
)
ííW X
;
ííX Y
var
ìì  
propertySetMethods
ìì &
=
ìì' ( 
AddPropertySetters
ìì) ;
(
ìì; <
typeDef
ìì< C
,
ììC D
genericTypeDef
ììE S
,
ììS T
typeInfo
ììU ]
)
ìì] ^
;
ìì^ _
var
îî 
postInjectMethods
îî %
=
îî& '"
AddPostInjectMethods
îî( <
(
îî< =
typeDef
îî= D
,
îîD E
genericTypeDef
îîF T
,
îîT U
typeInfo
îîV ^
)
îî^ _
;
îî_ `!
CreateGetInfoMethod
ññ #
(
ññ# $
typeDef
óó 
,
óó 
genericTypeDef
óó +
,
óó+ ,
typeInfo
óó- 5
,
óó5 6
factoryMethod
òò !
,
òò! "
fieldSetMethods
òò# 2
,
òò2 3 
propertySetMethods
òò4 F
,
òòF G
postInjectMethods
òòH Y
)
òòY Z
;
òòZ [
}
ôô 
catch
öö 
(
öö 
	Exception
öö 
e
öö 
)
öö 
{
õõ 
Log
úú 
.
úú 
ErrorException
úú "
(
úú" #
$str
úú# D
.
úúD E
Fmt
úúE H
(
úúH I

actualType
úúI S
)
úúS T
,
úúT U
e
úúV W
)
úúW X
;
úúX Y
throw
ùù 
;
ùù 
}
ûû 
return
†† 
true
†† 
;
†† 
}
°° 	
static
££ 
bool
££ 
IsStaticClass
££ !
(
££! "
Type
££" &
type
££' +
)
££+ ,
{
§§ 	
return
¶¶ 
type
¶¶ 
.
¶¶ 

IsAbstract
¶¶ "
&&
¶¶# %
type
¶¶& *
.
¶¶* +
IsSealed
¶¶+ 3
;
¶¶3 4
}
ßß 	
bool
™™ 
IsTypeProcessed
™™ 
(
™™ 
TypeDefinition
™™ +
typeDef
™™, 3
)
™™3 4
{
´´ 	
return
¨¨ 
typeDef
¨¨ 
.
¨¨ 
	GetMethod
¨¨ $
(
¨¨$ %
TypeAnalyzer
¨¨% 1
.
¨¨1 25
'ReflectionBakingGetInjectInfoMethodName
¨¨2 Y
)
¨¨Y Z
!=
¨¨[ ]
null
¨¨^ b
;
¨¨b c
}
≠≠ 	
void
ØØ 
EmitCastOperation
ØØ 
(
ØØ 
ILProcessor
ØØ *
	processor
ØØ+ 4
,
ØØ4 5
Type
ØØ6 :
type
ØØ; ?
,
ØØ? @

Collection
ØØA K
<
ØØK L
GenericParameter
ØØL \
>
ØØ\ ]
genericParams
ØØ^ k
)
ØØk l
{
∞∞ 	
if
±± 
(
±± 
type
±± 
.
±±  
IsGenericParameter
±± '
)
±±' (
{
≤≤ 
	processor
≥≥ 
.
≥≥ 
Emit
≥≥ 
(
≥≥ 
OpCodes
≥≥ &
.
≥≥& '
	Unbox_Any
≥≥' 0
,
≥≥0 1
genericParams
≥≥2 ?
[
≥≥? @
type
≥≥@ D
.
≥≥D E&
GenericParameterPosition
≥≥E ]
]
≥≥] ^
)
≥≥^ _
;
≥≥_ `
}
¥¥ 
else
µµ 
if
µµ 
(
µµ 
type
µµ 
.
µµ 
IsEnum
µµ  
)
µµ  !
{
∂∂ 
	processor
∑∑ 
.
∑∑ 
Emit
∑∑ 
(
∑∑ 
OpCodes
∑∑ &
.
∑∑& '
	Unbox_Any
∑∑' 0
,
∑∑0 1
_module
∑∑2 9
.
∑∑9 :

TypeSystem
∑∑: D
.
∑∑D E
Int32
∑∑E J
)
∑∑J K
;
∑∑K L
}
∏∏ 
else
ππ 
if
ππ 
(
ππ 
type
ππ 
.
ππ 
IsValueType
ππ %
)
ππ% &
{
∫∫ 
	processor
ªª 
.
ªª 
Emit
ªª 
(
ªª 
OpCodes
ªª &
.
ªª& '
	Unbox_Any
ªª' 0
,
ªª0 1
_module
ªª2 9
.
ªª9 :

ImportType
ªª: D
(
ªªD E
type
ªªE I
)
ªªI J
)
ªªJ K
;
ªªK L
}
ºº 
else
ΩΩ 
{
ææ 
	processor
øø 
.
øø 
Emit
øø 
(
øø 
OpCodes
øø &
.
øø& '
	Castclass
øø' 0
,
øø0 1.
 CreateGenericInstanceIfNecessary
øø2 R
(
øøR S
type
øøS W
,
øøW X
genericParams
øøY f
)
øøf g
)
øøg h
;
øøh i
}
¿¿ 
}
¡¡ 	
TypeReference
√√ 1
#CreateGenericInstanceWithParameters
√√ 9
(
√√9 :
TypeDefinition
√√: H
typeDef
√√I P
)
√√P Q
{
ƒƒ 	
if
≈≈ 
(
≈≈ 
typeDef
≈≈ 
.
≈≈ 
GenericParameters
≈≈ )
.
≈≈) *
Any
≈≈* -
(
≈≈- .
)
≈≈. /
)
≈≈/ 0
{
∆∆ 
var
«« 
genericInstance
«« #
=
««$ %
new
««& )!
GenericInstanceType
««* =
(
««= >
typeDef
««> E
)
««E F
;
««F G
foreach
…… 
(
…… 
var
…… 
	parameter
…… &
in
……' )
typeDef
……* 1
.
……1 2
GenericParameters
……2 C
)
……C D
{
   
genericInstance
ÀÀ #
.
ÀÀ# $
GenericArguments
ÀÀ$ 4
.
ÀÀ4 5
Add
ÀÀ5 8
(
ÀÀ8 9
	parameter
ÀÀ9 B
)
ÀÀB C
;
ÀÀC D
}
ÃÃ 
return
ŒŒ 
genericInstance
ŒŒ &
;
ŒŒ& '
}
œœ 
return
—— 
typeDef
—— 
;
—— 
}
““ 	
MethodDefinition
‘‘ !
TryAddFactoryMethod
‘‘ ,
(
‘‘, -
TypeDefinition
’’ 
typeDef
’’ "
,
’’" # 
ReflectionTypeInfo
’’$ 6
typeInfo
’’7 ?
)
’’? @
{
÷÷ 	
if
◊◊ 
(
◊◊ 
typeInfo
◊◊ 
.
◊◊ 
Type
◊◊ 
.
◊◊ 
GetParentTypes
◊◊ ,
(
◊◊, -
)
◊◊- .
.
◊◊. /
Any
◊◊/ 2
(
◊◊2 3
x
◊◊3 4
=>
◊◊5 7
x
◊◊8 9
.
◊◊9 :
FullName
◊◊: B
==
◊◊C E
$str
◊◊F ]
)
◊◊] ^
)
◊◊^ _
{
ÿÿ 
Assert
ŸŸ 
.
ŸŸ 
That
ŸŸ 
(
ŸŸ 
typeInfo
ŸŸ $
.
ŸŸ$ %
InjectConstructor
ŸŸ% 6
.
ŸŸ6 7

Parameters
ŸŸ7 A
.
ŸŸA B
IsEmpty
ŸŸB I
(
ŸŸI J
)
ŸŸJ K
)
ŸŸK L
;
ŸŸL M
return
⁄⁄ 
null
⁄⁄ 
;
⁄⁄ 
}
€€ 
if
›› 
(
›› 
typeInfo
›› 
.
›› 
InjectConstructor
›› *
.
››* +
ConstructorInfo
››+ :
==
››; =
null
››> B
)
››B C
{
ﬁﬁ 
return
‡‡ 
null
‡‡ 
;
‡‡ 
}
·· 
var
„„ 
factoryMethod
„„ 
=
„„ 
new
„„  #
MethodDefinition
„„$ 4
(
„„4 5
TypeAnalyzer
‰‰ 
.
‰‰ /
!ReflectionBakingFactoryMethodName
‰‰ >
,
‰‰> ?
MethodAttributes
ÂÂ  
.
ÂÂ  !
Private
ÂÂ! (
|
ÂÂ) *
MethodAttributes
ÂÂ+ ;
.
ÂÂ; <
	HideBySig
ÂÂ< E
|
ÂÂF G
MethodAttributes
ÊÊ  
.
ÊÊ  !
Static
ÊÊ! '
,
ÊÊ' (
_module
ÁÁ 
.
ÁÁ 

TypeSystem
ÁÁ "
.
ÁÁ" #
Object
ÁÁ# )
)
ÁÁ) *
;
ÁÁ* +
var
ÈÈ 
p1
ÈÈ 
=
ÈÈ 
new
ÈÈ !
ParameterDefinition
ÈÈ ,
(
ÈÈ, -
_objectArrayType
ÈÈ- =
)
ÈÈ= >
;
ÈÈ> ?
p1
ÍÍ 
.
ÍÍ 
Name
ÍÍ 
=
ÍÍ 
$str
ÍÍ 
;
ÍÍ 
factoryMethod
ÎÎ 
.
ÎÎ 

Parameters
ÎÎ $
.
ÎÎ$ %
Add
ÎÎ% (
(
ÎÎ( )
p1
ÎÎ) +
)
ÎÎ+ ,
;
ÎÎ, -
var
ÌÌ 
body
ÌÌ 
=
ÌÌ 
factoryMethod
ÌÌ $
.
ÌÌ$ %
Body
ÌÌ% )
;
ÌÌ) *
body
ÓÓ 
.
ÓÓ 

InitLocals
ÓÓ 
=
ÓÓ 
true
ÓÓ "
;
ÓÓ" #
var
 
	processor
 
=
 
body
  
.
  !
GetILProcessor
! /
(
/ 0
)
0 1
;
1 2
var
ÚÚ 
returnValueVar
ÚÚ 
=
ÚÚ  
new
ÚÚ! $ 
VariableDefinition
ÚÚ% 7
(
ÚÚ7 8
_module
ÚÚ8 ?
.
ÚÚ? @

TypeSystem
ÚÚ@ J
.
ÚÚJ K
Object
ÚÚK Q
)
ÚÚQ R
;
ÚÚR S
body
ÛÛ 
.
ÛÛ 
	Variables
ÛÛ 
.
ÛÛ 
Add
ÛÛ 
(
ÛÛ 
returnValueVar
ÛÛ -
)
ÛÛ- .
;
ÛÛ. /
	processor
ıı 
.
ıı 
Emit
ıı 
(
ıı 
OpCodes
ıı "
.
ıı" #
Nop
ıı# &
)
ıı& '
;
ıı' (
Assert
˜˜ 
.
˜˜ 
	IsNotNull
˜˜ 
(
˜˜ 
typeInfo
˜˜ %
.
˜˜% &
InjectConstructor
˜˜& 7
)
˜˜7 8
;
˜˜8 9
var
˘˘ 
args
˘˘ 
=
˘˘ 
typeInfo
˘˘ 
.
˘˘  
InjectConstructor
˘˘  1
.
˘˘1 2

Parameters
˘˘2 <
;
˘˘< =
for
˚˚ 
(
˚˚ 
int
˚˚ 
i
˚˚ 
=
˚˚ 
$num
˚˚ 
;
˚˚ 
i
˚˚ 
<
˚˚ 
args
˚˚  $
.
˚˚$ %
Count
˚˚% *
;
˚˚* +
i
˚˚, -
++
˚˚- /
)
˚˚/ 0
{
¸¸ 
var
˝˝ 
arg
˝˝ 
=
˝˝ 
args
˝˝ 
[
˝˝ 
i
˝˝  
]
˝˝  !
;
˝˝! "
	processor
ˇˇ 
.
ˇˇ 
Emit
ˇˇ 
(
ˇˇ 
OpCodes
ˇˇ &
.
ˇˇ& '
Ldarg_0
ˇˇ' .
)
ˇˇ. /
;
ˇˇ/ 0
	processor
ÄÄ 
.
ÄÄ 
Emit
ÄÄ 
(
ÄÄ 
OpCodes
ÄÄ &
.
ÄÄ& '
Ldc_I4
ÄÄ' -
,
ÄÄ- .
i
ÄÄ/ 0
)
ÄÄ0 1
;
ÄÄ1 2
	processor
ÅÅ 
.
ÅÅ 
Emit
ÅÅ 
(
ÅÅ 
OpCodes
ÅÅ &
.
ÅÅ& '

Ldelem_Ref
ÅÅ' 1
)
ÅÅ1 2
;
ÅÅ2 3
EmitCastOperation
ÉÉ !
(
ÉÉ! "
	processor
ÑÑ 
,
ÑÑ 
arg
ÑÑ "
.
ÑÑ" #
ParameterInfo
ÑÑ# 0
.
ÑÑ0 1
ParameterType
ÑÑ1 >
,
ÑÑ> ?
typeDef
ÑÑ@ G
.
ÑÑG H
GenericParameters
ÑÑH Y
)
ÑÑY Z
;
ÑÑZ [
}
ÖÖ 
	processor
áá 
.
áá 
Emit
áá 
(
áá 
OpCodes
áá "
.
áá" #
Newobj
áá# )
,
áá) *
_module
áá+ 2
.
áá2 3
Import
áá3 9
(
áá9 :
typeInfo
áá: B
.
ááB C
InjectConstructor
ááC T
.
ááT U
ConstructorInfo
ááU d
)
áád e
)
ááe f
;
ááf g
	processor
ââ 
.
ââ 
Emit
ââ 
(
ââ 
OpCodes
ââ "
.
ââ" #
Stloc_0
ââ# *
)
ââ* +
;
ââ+ ,
	processor
ää 
.
ää 
Emit
ää 
(
ää 
OpCodes
ää "
.
ää" #
Ldloc_S
ää# *
,
ää* +
returnValueVar
ää, :
)
ää: ;
;
ää; <
	processor
ãã 
.
ãã 
Emit
ãã 
(
ãã 
OpCodes
ãã "
.
ãã" #
Ret
ãã# &
)
ãã& '
;
ãã' (
typeDef
çç 
.
çç 
Methods
çç 
.
çç 
Add
çç 
(
çç  
factoryMethod
çç  -
)
çç- .
;
çç. /
return
èè 
factoryMethod
èè  
;
èè  !
}
êê 	
void
íí %
AddPostInjectMethodBody
íí $
(
íí$ %
ILProcessor
ìì 
	processor
ìì !
,
ìì! " 
ReflectionTypeInfo
ìì# 5
.
ìì5 6
InjectMethodInfo
ìì6 F
postInjectInfo
ììG U
,
ììU V
TypeDefinition
ììW e
typeDef
ììf m
,
ììm n
TypeReference
ììo |
genericTypeDefìì} ã
)ììã å
{
îî 	
	processor
ïï 
.
ïï 
Emit
ïï 
(
ïï 
OpCodes
ïï "
.
ïï" #
Nop
ïï# &
)
ïï& '
;
ïï' (
TypeReference
óó 
declaringTypeDef
óó *
;
óó* +
MethodReference
òò 
actualMethodDef
òò +
;
òò+ ,
if
öö 
(
öö 
!
öö  
TryFindLocalMethod
öö #
(
öö# $
genericTypeDef
õõ 
,
õõ 
postInjectInfo
õõ  .
.
õõ. /

MethodInfo
õõ/ 9
.
õõ9 :
Name
õõ: >
,
õõ> ?
out
õõ@ C
declaringTypeDef
õõD T
,
õõT U
out
õõV Y
actualMethodDef
õõZ i
)
õõi j
)
õõj k
{
úú 
throw
ùù 
Assert
ùù 
.
ùù 
CreateException
ùù ,
(
ùù, -
)
ùù- .
;
ùù. /
}
ûû 
	processor
†† 
.
†† 
Emit
†† 
(
†† 
OpCodes
†† "
.
††" #
Ldarg_0
††# *
)
††* +
;
††+ ,
	processor
°° 
.
°° 
Emit
°° 
(
°° 
OpCodes
°° "
.
°°" #
	Castclass
°°# ,
,
°°, -
declaringTypeDef
°°. >
)
°°> ?
;
°°? @
for
££ 
(
££ 
int
££ 
k
££ 
=
££ 
$num
££ 
;
££ 
k
££ 
<
££ 
postInjectInfo
££  .
.
££. /

Parameters
££/ 9
.
££9 :
Count
££: ?
;
££? @
k
££A B
++
££B D
)
££D E
{
§§ 
var
•• 

injectInfo
•• 
=
••  
postInjectInfo
••! /
.
••/ 0

Parameters
••0 :
[
••: ;
k
••; <
]
••< =
;
••= >
	processor
ßß 
.
ßß 
Emit
ßß 
(
ßß 
OpCodes
ßß &
.
ßß& '
Ldarg_1
ßß' .
)
ßß. /
;
ßß/ 0
	processor
®® 
.
®® 
Emit
®® 
(
®® 
OpCodes
®® &
.
®®& '
Ldc_I4
®®' -
,
®®- .
k
®®/ 0
)
®®0 1
;
®®1 2
	processor
©© 
.
©© 
Emit
©© 
(
©© 
OpCodes
©© &
.
©©& '

Ldelem_Ref
©©' 1
)
©©1 2
;
©©2 3
EmitCastOperation
´´ !
(
´´! "
	processor
´´" +
,
´´+ ,

injectInfo
´´- 7
.
´´7 8
ParameterInfo
´´8 E
.
´´E F
ParameterType
´´F S
,
´´S T
typeDef
´´U \
.
´´\ ]
GenericParameters
´´] n
)
´´n o
;
´´o p
}
¨¨ 
	processor
ÆÆ 
.
ÆÆ 
Emit
ÆÆ 
(
ÆÆ 
OpCodes
ÆÆ "
.
ÆÆ" #
Callvirt
ÆÆ# +
,
ÆÆ+ ,
actualMethodDef
ÆÆ- <
)
ÆÆ< =
;
ÆÆ= >
	processor
ØØ 
.
ØØ 
Emit
ØØ 
(
ØØ 
OpCodes
ØØ "
.
ØØ" #
Ret
ØØ# &
)
ØØ& '
;
ØØ' (
}
∞∞ 	
MethodDefinition
≤≤ !
AddPostInjectMethod
≤≤ ,
(
≤≤, -
string
≥≥ 
name
≥≥ 
,
≥≥  
ReflectionTypeInfo
≥≥ +
.
≥≥+ ,
InjectMethodInfo
≥≥, <
postInjectInfo
≥≥= K
,
≥≥K L
TypeDefinition
≥≥M [
typeDef
≥≥\ c
,
≥≥c d
TypeReference
≥≥e r
genericTypeDef≥≥s Å
)≥≥Å Ç
{
¥¥ 	
var
µµ 
	methodDef
µµ 
=
µµ 
new
µµ 
MethodDefinition
µµ  0
(
µµ0 1
name
∂∂ 
,
∂∂ 
MethodAttributes
∑∑  
.
∑∑  !
Private
∑∑! (
|
∑∑) *
MethodAttributes
∑∑+ ;
.
∑∑; <
	HideBySig
∑∑< E
|
∑∑F G
MethodAttributes
∏∏  
.
∏∏  !
Static
∏∏! '
,
∏∏' (
_module
ππ 
.
ππ 

TypeSystem
ππ "
.
ππ" #
Void
ππ# '
)
ππ' (
;
ππ( )
var
ªª 
p1
ªª 
=
ªª 
new
ªª !
ParameterDefinition
ªª ,
(
ªª, -
_module
ªª- 4
.
ªª4 5

TypeSystem
ªª5 ?
.
ªª? @
Object
ªª@ F
)
ªªF G
;
ªªG H
p1
ºº 
.
ºº 
Name
ºº 
=
ºº 
$str
ºº 
;
ºº 
	methodDef
ΩΩ 
.
ΩΩ 

Parameters
ΩΩ  
.
ΩΩ  !
Add
ΩΩ! $
(
ΩΩ$ %
p1
ΩΩ% '
)
ΩΩ' (
;
ΩΩ( )
var
øø 
p2
øø 
=
øø 
new
øø !
ParameterDefinition
øø ,
(
øø, -
_objectArrayType
øø- =
)
øø= >
;
øø> ?
p2
¿¿ 
.
¿¿ 
Name
¿¿ 
=
¿¿ 
$str
¿¿ 
;
¿¿ 
	methodDef
¡¡ 
.
¡¡ 

Parameters
¡¡  
.
¡¡  !
Add
¡¡! $
(
¡¡$ %
p2
¡¡% '
)
¡¡' (
;
¡¡( )
var
√√ 
body
√√ 
=
√√ 
	methodDef
√√  
.
√√  !
Body
√√! %
;
√√% &
var
ƒƒ 
	processor
ƒƒ 
=
ƒƒ 
body
ƒƒ  
.
ƒƒ  !
GetILProcessor
ƒƒ! /
(
ƒƒ/ 0
)
ƒƒ0 1
;
ƒƒ1 2%
AddPostInjectMethodBody
∆∆ #
(
∆∆# $
	processor
∆∆$ -
,
∆∆- .
postInjectInfo
∆∆/ =
,
∆∆= >
typeDef
∆∆? F
,
∆∆F G
genericTypeDef
∆∆H V
)
∆∆V W
;
∆∆W X
typeDef
»» 
.
»» 
Methods
»» 
.
»» 
Add
»» 
(
»»  
	methodDef
»»  )
)
»») *
;
»»* +
return
   
	methodDef
   
;
   
}
ÀÀ 	
List
ÕÕ 
<
ÕÕ 
MethodDefinition
ÕÕ 
>
ÕÕ "
AddPostInjectMethods
ÕÕ 3
(
ÕÕ3 4
TypeDefinition
ŒŒ 
typeDef
ŒŒ "
,
ŒŒ" #
TypeReference
ŒŒ$ 1
genericTypeDef
ŒŒ2 @
,
ŒŒ@ A 
ReflectionTypeInfo
ŒŒB T
typeInfo
ŒŒU ]
)
ŒŒ] ^
{
œœ 	
var
–– 
postInjectMethods
–– !
=
––" #
new
––$ '
List
––( ,
<
––, -
MethodDefinition
––- =
>
––= >
(
––> ?
)
––? @
;
––@ A
for
““ 
(
““ 
int
““ 
i
““ 
=
““ 
$num
““ 
;
““ 
i
““ 
<
““ 
typeInfo
““  (
.
““( )
InjectMethods
““) 6
.
““6 7
Count
““7 <
;
““< =
i
““> ?
++
““? A
)
““A B
{
”” 
postInjectMethods
‘‘ !
.
‘‘! "
Add
‘‘" %
(
‘‘% &!
AddPostInjectMethod
’’ '
(
’’' (
TypeAnalyzer
÷÷ $
.
÷÷$ %0
"ReflectionBakingInjectMethodPrefix
÷÷% G
+
÷÷H I
i
÷÷J K
,
÷÷K L
typeInfo
÷÷M U
.
÷÷U V
InjectMethods
÷÷V c
[
÷÷c d
i
÷÷d e
]
÷÷e f
,
÷÷f g
typeDef
÷÷h o
,
÷÷o p
genericTypeDef
÷÷q 
)÷÷ Ä
)÷÷Ä Å
;÷÷Å Ç
}
◊◊ 
return
ŸŸ 
postInjectMethods
ŸŸ $
;
ŸŸ$ %
}
⁄⁄ 	
void
‹‹ 
EmitSetterMethod
‹‹ 
(
‹‹ 
ILProcessor
›› 
	processor
›› !
,
››! "

MemberInfo
››# -

memberInfo
››. 8
,
››8 9
TypeDefinition
››: H
typeDef
››I P
,
››P Q
TypeReference
››R _
genericTypeDef
››` n
)
››n o
{
ﬁﬁ 	
	processor
ﬂﬂ 
.
ﬂﬂ 
Emit
ﬂﬂ 
(
ﬂﬂ 
OpCodes
ﬂﬂ "
.
ﬂﬂ" #
Nop
ﬂﬂ# &
)
ﬂﬂ& '
;
ﬂﬂ' (
	processor
·· 
.
·· 
Emit
·· 
(
·· 
OpCodes
·· "
.
··" #
Ldarg_0
··# *
)
··* +
;
··+ ,
	processor
‚‚ 
.
‚‚ 
Emit
‚‚ 
(
‚‚ 
OpCodes
‚‚ "
.
‚‚" #
	Castclass
‚‚# ,
,
‚‚, -
genericTypeDef
‚‚. <
)
‚‚< =
;
‚‚= >
	processor
‰‰ 
.
‰‰ 
Emit
‰‰ 
(
‰‰ 
OpCodes
‰‰ "
.
‰‰" #
Ldarg_1
‰‰# *
)
‰‰* +
;
‰‰+ ,
if
ÊÊ 
(
ÊÊ 

memberInfo
ÊÊ 
is
ÊÊ 
	FieldInfo
ÊÊ '
)
ÊÊ' (
{
ÁÁ 
var
ËË 
	fieldInfo
ËË 
=
ËË 
(
ËË  !
	FieldInfo
ËË! *
)
ËË* +

memberInfo
ËË+ 5
;
ËË5 6
EmitCastOperation
ÍÍ !
(
ÍÍ! "
	processor
ÍÍ" +
,
ÍÍ+ ,
	fieldInfo
ÍÍ- 6
.
ÍÍ6 7
	FieldType
ÍÍ7 @
,
ÍÍ@ A
typeDef
ÍÍB I
.
ÍÍI J
GenericParameters
ÍÍJ [
)
ÍÍ[ \
;
ÍÍ\ ]
	processor
ÏÏ 
.
ÏÏ 
Emit
ÏÏ 
(
ÏÏ 
OpCodes
ÏÏ &
.
ÏÏ& '
Stfld
ÏÏ' ,
,
ÏÏ, -
FindLocalField
ÏÏ. <
(
ÏÏ< =
genericTypeDef
ÏÏ= K
,
ÏÏK L
	fieldInfo
ÏÏM V
.
ÏÏV W
Name
ÏÏW [
)
ÏÏ[ \
)
ÏÏ\ ]
;
ÏÏ] ^
}
ÌÌ 
else
ÓÓ 
{
ÔÔ 
var
 
propertyInfo
  
=
! "
(
# $
PropertyInfo
$ 0
)
0 1

memberInfo
1 ;
;
; <
EmitCastOperation
ÚÚ !
(
ÚÚ! "
	processor
ÚÚ" +
,
ÚÚ+ ,
propertyInfo
ÚÚ- 9
.
ÚÚ9 :
PropertyType
ÚÚ: F
,
ÚÚF G
typeDef
ÚÚH O
.
ÚÚO P
GenericParameters
ÚÚP a
)
ÚÚa b
;
ÚÚb c
	processor
ÙÙ 
.
ÙÙ 
Emit
ÙÙ 
(
ÙÙ 
OpCodes
ÙÙ &
.
ÙÙ& '
Callvirt
ÙÙ' /
,
ÙÙ/ 0(
FindLocalPropertySetMethod
ÙÙ1 K
(
ÙÙK L
genericTypeDef
ÙÙL Z
,
ÙÙZ [
propertyInfo
ÙÙ\ h
.
ÙÙh i
Name
ÙÙi m
)
ÙÙm n
)
ÙÙn o
;
ÙÙo p
}
ıı 
	processor
˜˜ 
.
˜˜ 
Emit
˜˜ 
(
˜˜ 
OpCodes
˜˜ "
.
˜˜" #
Ret
˜˜# &
)
˜˜& '
;
˜˜' (
}
¯¯ 	
MethodDefinition
˙˙ 
AddSetterMethod
˙˙ (
(
˙˙( )
string
˚˚ 
name
˚˚ 
,
˚˚ 

MemberInfo
˚˚ #

memberInfo
˚˚$ .
,
˚˚. /
TypeDefinition
˚˚0 >
typeDef
˚˚? F
,
˚˚F G
TypeReference
˚˚H U
genericTypeDef
˚˚V d
)
˚˚d e
{
¸¸ 	
var
˝˝ 
	methodDef
˝˝ 
=
˝˝ 
new
˝˝ 
MethodDefinition
˝˝  0
(
˝˝0 1
name
˛˛ 
,
˛˛ 
MethodAttributes
ˇˇ  
.
ˇˇ  !
Private
ˇˇ! (
|
ˇˇ) *
MethodAttributes
ˇˇ+ ;
.
ˇˇ; <
	HideBySig
ˇˇ< E
|
ˇˇF G
MethodAttributes
ÄÄ  
.
ÄÄ  !
Static
ÄÄ! '
,
ÄÄ' (
_module
ÅÅ 
.
ÅÅ 

TypeSystem
ÅÅ "
.
ÅÅ" #
Void
ÅÅ# '
)
ÅÅ' (
;
ÅÅ( )
var
ÉÉ 
p1
ÉÉ 
=
ÉÉ 
new
ÉÉ !
ParameterDefinition
ÉÉ ,
(
ÉÉ, -
_module
ÉÉ- 4
.
ÉÉ4 5

TypeSystem
ÉÉ5 ?
.
ÉÉ? @
Object
ÉÉ@ F
)
ÉÉF G
;
ÉÉG H
p1
ÑÑ 
.
ÑÑ 
Name
ÑÑ 
=
ÑÑ 
$str
ÑÑ 
;
ÑÑ 
	methodDef
ÖÖ 
.
ÖÖ 

Parameters
ÖÖ  
.
ÖÖ  !
Add
ÖÖ! $
(
ÖÖ$ %
p1
ÖÖ% '
)
ÖÖ' (
;
ÖÖ( )
var
áá 
p2
áá 
=
áá 
new
áá !
ParameterDefinition
áá ,
(
áá, -
_module
áá- 4
.
áá4 5

TypeSystem
áá5 ?
.
áá? @
Object
áá@ F
)
ááF G
;
ááG H
p2
àà 
.
àà 
Name
àà 
=
àà 
$str
àà 
;
àà 
	methodDef
ââ 
.
ââ 

Parameters
ââ  
.
ââ  !
Add
ââ! $
(
ââ$ %
p2
ââ% '
)
ââ' (
;
ââ( )
	methodDef
ãã 
.
ãã 
Body
ãã 
.
ãã 

InitLocals
ãã %
=
ãã& '
true
ãã( ,
;
ãã, -
EmitSetterMethod
çç 
(
çç 
	methodDef
éé 
.
éé 
Body
éé 
.
éé 
GetILProcessor
éé -
(
éé- .
)
éé. /
,
éé/ 0

memberInfo
éé1 ;
,
éé; <
typeDef
éé= D
,
ééD E
genericTypeDef
ééF T
)
ééT U
;
ééU V
typeDef
êê 
.
êê 
Methods
êê 
.
êê 
Add
êê 
(
êê  
	methodDef
êê  )
)
êê) *
;
êê* +
return
íí 
	methodDef
íí 
;
íí 
}
ìì 	
List
ïï 
<
ïï 
MethodDefinition
ïï 
>
ïï  
AddPropertySetters
ïï 1
(
ïï1 2
TypeDefinition
ññ 
typeDef
ññ "
,
ññ" #
TypeReference
ññ$ 1
genericTypeDef
ññ2 @
,
ññ@ A 
ReflectionTypeInfo
ññB T
typeInfo
ññU ]
)
ññ] ^
{
óó 	
var
òò 

methodDefs
òò 
=
òò 
new
òò  
List
òò! %
<
òò% &
MethodDefinition
òò& 6
>
òò6 7
(
òò7 8
)
òò8 9
;
òò9 :
for
öö 
(
öö 
int
öö 
i
öö 
=
öö 
$num
öö 
;
öö 
i
öö 
<
öö 
typeInfo
öö  (
.
öö( )
InjectProperties
öö) 9
.
öö9 :
Count
öö: ?
;
öö? @
i
ööA B
++
ööB D
)
ööD E
{
õõ 

methodDefs
úú 
.
úú 
Add
úú 
(
úú 
AddSetterMethod
ùù #
(
ùù# $
TypeAnalyzer
ûû $
.
ûû$ %2
$ReflectionBakingPropertySetterPrefix
ûû% I
+
ûûJ K
i
ûûL M
,
ûûM N
typeInfo
üü  
.
üü  !
InjectProperties
üü! 1
[
üü1 2
i
üü2 3
]
üü3 4
.
üü4 5
PropertyInfo
üü5 A
,
üüA B
typeDef
üüC J
,
üüJ K
genericTypeDef
üüL Z
)
üüZ [
)
üü[ \
;
üü\ ]
}
†† 
return
¢¢ 

methodDefs
¢¢ 
;
¢¢ 
}
££ 	
List
•• 
<
•• 
MethodDefinition
•• 
>
•• 
AddFieldSetters
•• .
(
••. /
TypeDefinition
¶¶ 
typeDef
¶¶ "
,
¶¶" #
TypeReference
¶¶$ 1
genericTypeDef
¶¶2 @
,
¶¶@ A 
ReflectionTypeInfo
¶¶B T
typeInfo
¶¶U ]
)
¶¶] ^
{
ßß 	
var
®® 

methodDefs
®® 
=
®® 
new
®®  
List
®®! %
<
®®% &
MethodDefinition
®®& 6
>
®®6 7
(
®®7 8
)
®®8 9
;
®®9 :
for
™™ 
(
™™ 
int
™™ 
i
™™ 
=
™™ 
$num
™™ 
;
™™ 
i
™™ 
<
™™ 
typeInfo
™™  (
.
™™( )
InjectFields
™™) 5
.
™™5 6
Count
™™6 ;
;
™™; <
i
™™= >
++
™™> @
)
™™@ A
{
´´ 

methodDefs
¨¨ 
.
¨¨ 
Add
¨¨ 
(
¨¨ 
AddSetterMethod
≠≠ #
(
≠≠# $
TypeAnalyzer
ÆÆ $
.
ÆÆ$ %/
!ReflectionBakingFieldSetterPrefix
ÆÆ% F
+
ÆÆG H
i
ÆÆI J
,
ÆÆJ K
typeInfo
ØØ  
.
ØØ  !
InjectFields
ØØ! -
[
ØØ- .
i
ØØ. /
]
ØØ/ 0
.
ØØ0 1
	FieldInfo
ØØ1 :
,
ØØ: ;
typeDef
ØØ< C
,
ØØC D
genericTypeDef
ØØE S
)
ØØS T
)
ØØT U
;
ØØU V
}
∞∞ 
return
≤≤ 

methodDefs
≤≤ 
;
≤≤ 
}
≥≥ 	
void
µµ !
CreateGetInfoMethod
µµ  
(
µµ  !
TypeDefinition
∂∂ 
typeDef
∂∂ "
,
∂∂" #
TypeReference
∂∂$ 1
genericTypeDef
∂∂2 @
,
∂∂@ A 
ReflectionTypeInfo
∂∂B T
typeInfo
∂∂U ]
,
∂∂] ^
MethodDefinition
∑∑ 
factoryMethod
∑∑ *
,
∑∑* +
List
∑∑, 0
<
∑∑0 1
MethodDefinition
∑∑1 A
>
∑∑A B
fieldSetMethods
∑∑C R
,
∑∑R S
List
∏∏ 
<
∏∏ 
MethodDefinition
∏∏ !
>
∏∏! " 
propertySetMethods
∏∏# 5
,
∏∏5 6
List
∏∏7 ;
<
∏∏; <
MethodDefinition
∏∏< L
>
∏∏L M
postInjectMethods
∏∏N _
)
∏∏_ `
{
ππ 	
var
∫∫ 
getInfoMethodDef
∫∫  
=
∫∫! "
new
∫∫# &
MethodDefinition
∫∫' 7
(
∫∫7 8
TypeAnalyzer
ªª 
.
ªª 5
'ReflectionBakingGetInjectInfoMethodName
ªª D
,
ªªD E
MethodAttributes
ºº  
.
ºº  !
Private
ºº! (
|
ºº) *
MethodAttributes
ºº+ ;
.
ºº; <
	HideBySig
ºº< E
|
ººF G
MethodAttributes
ΩΩ  
.
ΩΩ  !
Static
ΩΩ! '
,
ΩΩ' ("
_zenjectTypeInfoType
ææ $
)
ææ$ %
;
ææ% &
typeDef
¿¿ 
.
¿¿ 
Methods
¿¿ 
.
¿¿ 
Add
¿¿ 
(
¿¿  
getInfoMethodDef
¿¿  0
)
¿¿0 1
;
¿¿1 2
getInfoMethodDef
¬¬ 
.
¬¬ 
CustomAttributes
¬¬ -
.
¬¬- .
Add
¬¬. 1
(
¬¬1 2
new
√√ 
CustomAttribute
√√ #
(
√√# $"
_preserveConstructor
√√$ 8
)
√√8 9
)
√√9 :
;
√√: ;
var
≈≈ 
returnValueVar
≈≈ 
=
≈≈  
new
≈≈! $ 
VariableDefinition
≈≈% 7
(
≈≈7 8
_module
≈≈8 ?
.
≈≈? @

TypeSystem
≈≈@ J
.
≈≈J K
Object
≈≈K Q
)
≈≈Q R
;
≈≈R S
var
«« 
body
«« 
=
«« 
getInfoMethodDef
«« '
.
««' (
Body
««( ,
;
««, -
body
…… 
.
…… 
	Variables
…… 
.
…… 
Add
…… 
(
…… 
returnValueVar
…… -
)
……- .
;
……. /
body
   
.
   

InitLocals
   
=
   
true
   "
;
  " #
var
ÃÃ 
instructions
ÃÃ 
=
ÃÃ 
new
ÃÃ "
List
ÃÃ# '
<
ÃÃ' (
Instruction
ÃÃ( 3
>
ÃÃ3 4
(
ÃÃ4 5
)
ÃÃ5 6
;
ÃÃ6 7
instructions
ŒŒ 
.
ŒŒ 
Add
ŒŒ 
(
ŒŒ 
Instruction
ŒŒ (
.
ŒŒ( )
Create
ŒŒ) /
(
ŒŒ/ 0
OpCodes
ŒŒ0 7
.
ŒŒ7 8
Ldtoken
ŒŒ8 ?
,
ŒŒ? @
genericTypeDef
ŒŒA O
)
ŒŒO P
)
ŒŒP Q
;
ŒŒQ R
instructions
œœ 
.
œœ 
Add
œœ 
(
œœ 
Instruction
œœ (
.
œœ( )
Create
œœ) /
(
œœ/ 0
OpCodes
œœ0 7
.
œœ7 8
Call
œœ8 <
,
œœ< =&
_getTypeFromHandleMethod
œœ> V
)
œœV W
)
œœW X
;
œœX Y
if
—— 
(
—— 
factoryMethod
—— 
==
——  
null
——! %
)
——% &
{
““ 
instructions
”” 
.
”” 
Add
””  
(
””  !
Instruction
””! ,
.
””, -
Create
””- 3
(
””3 4
OpCodes
””4 ;
.
””; <
Ldnull
””< B
)
””B C
)
””C D
;
””D E
}
‘‘ 
else
’’ 
{
÷÷ 
instructions
◊◊ 
.
◊◊ 
Add
◊◊  
(
◊◊  !
Instruction
◊◊! ,
.
◊◊, -
Create
◊◊- 3
(
◊◊3 4
OpCodes
◊◊4 ;
.
◊◊; <
Ldnull
◊◊< B
)
◊◊B C
)
◊◊C D
;
◊◊D E
instructions
ÿÿ 
.
ÿÿ 
Add
ÿÿ  
(
ÿÿ  !
Instruction
ÿÿ! ,
.
ÿÿ, -
Create
ÿÿ- 3
(
ÿÿ3 4
OpCodes
ÿÿ4 ;
.
ÿÿ; <
Ldftn
ÿÿ< A
,
ÿÿA B
factoryMethod
ÿÿC P
.
ÿÿP Q!
ChangeDeclaringType
ÿÿQ d
(
ÿÿd e
genericTypeDef
ÿÿe s
)
ÿÿs t
)
ÿÿt u
)
ÿÿu v
;
ÿÿv w
instructions
ŸŸ 
.
ŸŸ 
Add
ŸŸ  
(
ŸŸ  !
Instruction
ŸŸ! ,
.
ŸŸ, -
Create
ŸŸ- 3
(
ŸŸ3 4
OpCodes
ŸŸ4 ;
.
ŸŸ; <
Newobj
ŸŸ< B
,
ŸŸB C
_funcConstructor
ŸŸD T
)
ŸŸT U
)
ŸŸU V
;
ŸŸV W
}
⁄⁄ 
instructions
‹‹ 
.
‹‹ 
Add
‹‹ 
(
‹‹ 
Instruction
‹‹ (
.
‹‹( )
Create
‹‹) /
(
‹‹/ 0
OpCodes
‹‹0 7
.
‹‹7 8
Ldc_I4
‹‹8 >
,
‹‹> ?
typeInfo
‹‹@ H
.
‹‹H I
InjectConstructor
‹‹I Z
.
‹‹Z [

Parameters
‹‹[ e
.
‹‹e f
Count
‹‹f k
)
‹‹k l
)
‹‹l m
;
‹‹m n
instructions
›› 
.
›› 
Add
›› 
(
›› 
Instruction
›› (
.
››( )
Create
››) /
(
››/ 0
OpCodes
››0 7
.
››7 8
Newarr
››8 >
,
››> ?!
_injectableInfoType
››@ S
)
››S T
)
››T U
;
››U V
for
ﬂﬂ 
(
ﬂﬂ 
int
ﬂﬂ 
i
ﬂﬂ 
=
ﬂﬂ 
$num
ﬂﬂ 
;
ﬂﬂ 
i
ﬂﬂ 
<
ﬂﬂ 
typeInfo
ﬂﬂ  (
.
ﬂﬂ( )
InjectConstructor
ﬂﬂ) :
.
ﬂﬂ: ;

Parameters
ﬂﬂ; E
.
ﬂﬂE F
Count
ﬂﬂF K
;
ﬂﬂK L
i
ﬂﬂM N
++
ﬂﬂN P
)
ﬂﬂP Q
{
‡‡ 
var
·· 
injectableInfo
·· "
=
··# $
typeInfo
··% -
.
··- .
InjectConstructor
··. ?
.
··? @

Parameters
··@ J
[
··J K
i
··K L
]
··L M
.
··M N
InjectableInfo
··N \
;
··\ ]
instructions
„„ 
.
„„ 
Add
„„  
(
„„  !
Instruction
„„! ,
.
„„, -
Create
„„- 3
(
„„3 4
OpCodes
„„4 ;
.
„„; <
Dup
„„< ?
)
„„? @
)
„„@ A
;
„„A B
instructions
‰‰ 
.
‰‰ 
Add
‰‰  
(
‰‰  !
Instruction
‰‰! ,
.
‰‰, -
Create
‰‰- 3
(
‰‰3 4
OpCodes
‰‰4 ;
.
‰‰; <
Ldc_I4
‰‰< B
,
‰‰B C
i
‰‰D E
)
‰‰E F
)
‰‰F G
;
‰‰G H/
!EmitNewInjectableInfoInstructions
ÊÊ 1
(
ÊÊ1 2
instructions
ÁÁ  
,
ÁÁ  !
injectableInfo
ÁÁ" 0
,
ÁÁ0 1
typeDef
ÁÁ2 9
)
ÁÁ9 :
;
ÁÁ: ;
instructions
ÈÈ 
.
ÈÈ 
Add
ÈÈ  
(
ÈÈ  !
Instruction
ÈÈ! ,
.
ÈÈ, -
Create
ÈÈ- 3
(
ÈÈ3 4
OpCodes
ÈÈ4 ;
.
ÈÈ; <

Stelem_Ref
ÈÈ< F
)
ÈÈF G
)
ÈÈG H
;
ÈÈH I
}
ÍÍ 
instructions
ÏÏ 
.
ÏÏ 
Add
ÏÏ 
(
ÏÏ 
Instruction
ÏÏ (
.
ÏÏ( )
Create
ÏÏ) /
(
ÏÏ/ 0
OpCodes
ÏÏ0 7
.
ÏÏ7 8
Newobj
ÏÏ8 >
,
ÏÏ> ?)
_constructorInfoConstructor
ÏÏ@ [
)
ÏÏ[ \
)
ÏÏ\ ]
;
ÏÏ] ^
instructions
ÓÓ 
.
ÓÓ 
Add
ÓÓ 
(
ÓÓ 
Instruction
ÓÓ (
.
ÓÓ( )
Create
ÓÓ) /
(
ÓÓ/ 0
OpCodes
ÓÓ0 7
.
ÓÓ7 8
Ldc_I4
ÓÓ8 >
,
ÓÓ> ?
typeInfo
ÓÓ@ H
.
ÓÓH I
InjectMethods
ÓÓI V
.
ÓÓV W
Count
ÓÓW \
)
ÓÓ\ ]
)
ÓÓ] ^
;
ÓÓ^ _
instructions
ÔÔ 
.
ÔÔ 
Add
ÔÔ 
(
ÔÔ 
Instruction
ÔÔ (
.
ÔÔ( )
Create
ÔÔ) /
(
ÔÔ/ 0
OpCodes
ÔÔ0 7
.
ÔÔ7 8
Newarr
ÔÔ8 >
,
ÔÔ> ?#
_injectMethodInfoType
ÔÔ@ U
)
ÔÔU V
)
ÔÔV W
;
ÔÔW X
Assert
ÒÒ 
.
ÒÒ 
IsEqual
ÒÒ 
(
ÒÒ 
postInjectMethods
ÒÒ ,
.
ÒÒ, -
Count
ÒÒ- 2
,
ÒÒ2 3
typeInfo
ÒÒ4 <
.
ÒÒ< =
InjectMethods
ÒÒ= J
.
ÒÒJ K
Count
ÒÒK P
)
ÒÒP Q
;
ÒÒQ R
for
ÛÛ 
(
ÛÛ 
int
ÛÛ 
i
ÛÛ 
=
ÛÛ 
$num
ÛÛ 
;
ÛÛ 
i
ÛÛ 
<
ÛÛ 
typeInfo
ÛÛ  (
.
ÛÛ( )
InjectMethods
ÛÛ) 6
.
ÛÛ6 7
Count
ÛÛ7 <
;
ÛÛ< =
i
ÛÛ> ?
++
ÛÛ? A
)
ÛÛA B
{
ÙÙ 
var
ıı 
injectMethodInfo
ıı $
=
ıı% &
typeInfo
ıı' /
.
ıı/ 0
InjectMethods
ıı0 =
[
ıı= >
i
ıı> ?
]
ıı? @
;
ıı@ A
instructions
˜˜ 
.
˜˜ 
Add
˜˜  
(
˜˜  !
Instruction
˜˜! ,
.
˜˜, -
Create
˜˜- 3
(
˜˜3 4
OpCodes
˜˜4 ;
.
˜˜; <
Dup
˜˜< ?
)
˜˜? @
)
˜˜@ A
;
˜˜A B
instructions
¯¯ 
.
¯¯ 
Add
¯¯  
(
¯¯  !
Instruction
¯¯! ,
.
¯¯, -
Create
¯¯- 3
(
¯¯3 4
OpCodes
¯¯4 ;
.
¯¯; <
Ldc_I4
¯¯< B
,
¯¯B C
i
¯¯D E
)
¯¯E F
)
¯¯F G
;
¯¯G H-
AddInjectableMethodInstructions
˙˙ /
(
˙˙/ 0
instructions
˚˚  
,
˚˚  !
injectMethodInfo
˚˚" 2
,
˚˚2 3
typeDef
˚˚4 ;
,
˚˚; <
genericTypeDef
˚˚= K
,
˚˚K L
postInjectMethods
˚˚M ^
[
˚˚^ _
i
˚˚_ `
]
˚˚` a
)
˚˚a b
;
˚˚b c
instructions
˝˝ 
.
˝˝ 
Add
˝˝  
(
˝˝  !
Instruction
˝˝! ,
.
˝˝, -
Create
˝˝- 3
(
˝˝3 4
OpCodes
˝˝4 ;
.
˝˝; <

Stelem_Ref
˝˝< F
)
˝˝F G
)
˝˝G H
;
˝˝H I
}
˛˛ 
instructions
ÄÄ 
.
ÄÄ 
Add
ÄÄ 
(
ÄÄ 
Instruction
ÄÄ (
.
ÄÄ( )
Create
ÄÄ) /
(
ÄÄ/ 0
OpCodes
ÄÄ0 7
.
ÄÄ7 8
Ldc_I4
ÄÄ8 >
,
ÄÄ> ?
fieldSetMethods
ÄÄ@ O
.
ÄÄO P
Count
ÄÄP U
+
ÄÄV W 
propertySetMethods
ÄÄX j
.
ÄÄj k
Count
ÄÄk p
)
ÄÄp q
)
ÄÄq r
;
ÄÄr s
instructions
ÅÅ 
.
ÅÅ 
Add
ÅÅ 
(
ÅÅ 
Instruction
ÅÅ (
.
ÅÅ( )
Create
ÅÅ) /
(
ÅÅ/ 0
OpCodes
ÅÅ0 7
.
ÅÅ7 8
Newarr
ÅÅ8 >
,
ÅÅ> ?#
_injectMemberInfoType
ÅÅ@ U
)
ÅÅU V
)
ÅÅV W
;
ÅÅW X
for
ÉÉ 
(
ÉÉ 
int
ÉÉ 
i
ÉÉ 
=
ÉÉ 
$num
ÉÉ 
;
ÉÉ 
i
ÉÉ 
<
ÉÉ 
fieldSetMethods
ÉÉ  /
.
ÉÉ/ 0
Count
ÉÉ0 5
;
ÉÉ5 6
i
ÉÉ7 8
++
ÉÉ8 :
)
ÉÉ: ;
{
ÑÑ 
var
ÖÖ 
injectField
ÖÖ 
=
ÖÖ  !
typeInfo
ÖÖ" *
.
ÖÖ* +
InjectFields
ÖÖ+ 7
[
ÖÖ7 8
i
ÖÖ8 9
]
ÖÖ9 :
;
ÖÖ: ;
instructions
áá 
.
áá 
Add
áá  
(
áá  !
Instruction
áá! ,
.
áá, -
Create
áá- 3
(
áá3 4
OpCodes
áá4 ;
.
áá; <
Dup
áá< ?
)
áá? @
)
áá@ A
;
ááA B
instructions
àà 
.
àà 
Add
àà  
(
àà  !
Instruction
àà! ,
.
àà, -
Create
àà- 3
(
àà3 4
OpCodes
àà4 ;
.
àà; <
Ldc_I4
àà< B
,
ààB C
i
ààD E
)
ààE F
)
ààF G
;
ààG H-
AddInjectableMemberInstructions
ää /
(
ää/ 0
instructions
ãã  
,
ãã  !
injectField
åå 
.
åå  
InjectableInfo
åå  .
,
åå. /
injectField
åå0 ;
.
åå; <
	FieldInfo
åå< E
.
ååE F
Name
ååF J
,
ååJ K
typeDef
çç 
,
çç 
genericTypeDef
çç +
,
çç+ ,
fieldSetMethods
çç- <
[
çç< =
i
çç= >
]
çç> ?
)
çç? @
;
çç@ A
instructions
èè 
.
èè 
Add
èè  
(
èè  !
Instruction
èè! ,
.
èè, -
Create
èè- 3
(
èè3 4
OpCodes
èè4 ;
.
èè; <

Stelem_Ref
èè< F
)
èèF G
)
èèG H
;
èèH I
}
êê 
for
íí 
(
íí 
int
íí 
i
íí 
=
íí 
$num
íí 
;
íí 
i
íí 
<
íí  
propertySetMethods
íí  2
.
íí2 3
Count
íí3 8
;
íí8 9
i
íí: ;
++
íí; =
)
íí= >
{
ìì 
var
îî 
injectProperty
îî "
=
îî# $
typeInfo
îî% -
.
îî- .
InjectProperties
îî. >
[
îî> ?
i
îî? @
]
îî@ A
;
îîA B
instructions
ññ 
.
ññ 
Add
ññ  
(
ññ  !
Instruction
ññ! ,
.
ññ, -
Create
ññ- 3
(
ññ3 4
OpCodes
ññ4 ;
.
ññ; <
Dup
ññ< ?
)
ññ? @
)
ññ@ A
;
ññA B
instructions
óó 
.
óó 
Add
óó  
(
óó  !
Instruction
óó! ,
.
óó, -
Create
óó- 3
(
óó3 4
OpCodes
óó4 ;
.
óó; <
Ldc_I4
óó< B
,
óóB C
fieldSetMethods
óóD S
.
óóS T
Count
óóT Y
+
óóZ [
i
óó\ ]
)
óó] ^
)
óó^ _
;
óó_ `-
AddInjectableMemberInstructions
ôô /
(
ôô/ 0
instructions
öö  
,
öö  !
injectProperty
õõ "
.
õõ" #
InjectableInfo
õõ# 1
,
õõ1 2
injectProperty
úú "
.
úú" #
PropertyInfo
úú# /
.
úú/ 0
Name
úú0 4
,
úú4 5
typeDef
úú6 =
,
úú= >
genericTypeDef
úú? M
,
úúM N 
propertySetMethods
ùù &
[
ùù& '
i
ùù' (
]
ùù( )
)
ùù) *
;
ùù* +
instructions
üü 
.
üü 
Add
üü  
(
üü  !
Instruction
üü! ,
.
üü, -
Create
üü- 3
(
üü3 4
OpCodes
üü4 ;
.
üü; <

Stelem_Ref
üü< F
)
üüF G
)
üüG H
;
üüH I
}
†† 
instructions
¢¢ 
.
¢¢ 
Add
¢¢ 
(
¢¢ 
Instruction
¢¢ (
.
¢¢( )
Create
¢¢) /
(
¢¢/ 0
OpCodes
¢¢0 7
.
¢¢7 8
Newobj
¢¢8 >
,
¢¢> ?)
_zenjectTypeInfoConstructor
¢¢@ [
)
¢¢[ \
)
¢¢\ ]
;
¢¢] ^
instructions
§§ 
.
§§ 
Add
§§ 
(
§§ 
Instruction
§§ (
.
§§( )
Create
§§) /
(
§§/ 0
OpCodes
§§0 7
.
§§7 8
Stloc_0
§§8 ?
)
§§? @
)
§§@ A
;
§§A B
instructions
•• 
.
•• 
Add
•• 
(
•• 
Instruction
•• (
.
••( )
Create
••) /
(
••/ 0
OpCodes
••0 7
.
••7 8
Ldloc_S
••8 ?
,
••? @
returnValueVar
••A O
)
••O P
)
••P Q
;
••Q R
instructions
¶¶ 
.
¶¶ 
Add
¶¶ 
(
¶¶ 
Instruction
¶¶ (
.
¶¶( )
Create
¶¶) /
(
¶¶/ 0
OpCodes
¶¶0 7
.
¶¶7 8
Ret
¶¶8 ;
)
¶¶; <
)
¶¶< =
;
¶¶= >
var
®® 
	processor
®® 
=
®® 
body
®®  
.
®®  !
GetILProcessor
®®! /
(
®®/ 0
)
®®0 1
;
®®1 2
foreach
™™ 
(
™™ 
var
™™ 
instruction
™™ $
in
™™% '
instructions
™™( 4
)
™™4 5
{
´´ 
	processor
¨¨ 
.
¨¨ 
Append
¨¨  
(
¨¨  !
instruction
¨¨! ,
)
¨¨, -
;
¨¨- .
}
≠≠ 
}
ÆÆ 	
MethodReference
∞∞ (
FindLocalPropertySetMethod
∞∞ 2
(
∞∞2 3
TypeReference
±± 
specificTypeRef
±± )
,
±±) *
string
±±+ 1

memberName
±±2 <
)
±±< =
{
≤≤ 	
foreach
≥≥ 
(
≥≥ 
var
≥≥ 
typeRef
≥≥  
in
≥≥! #
specificTypeRef
≥≥$ 3
.
≥≥3 4)
GetSpecificBaseTypesAndSelf
≥≥4 O
(
≥≥O P
)
≥≥P Q
)
≥≥Q R
{
¥¥ 
var
µµ "
candidatePropertyDef
µµ (
=
µµ) *
typeRef
µµ+ 2
.
µµ2 3
Resolve
µµ3 :
(
µµ: ;
)
µµ; <
.
µµ< =

Properties
µµ= G
.
∂∂ 
Where
∂∂ 
(
∂∂ 
x
∂∂ 
=>
∂∂ 
x
∂∂  !
.
∂∂! "
Name
∂∂" &
==
∂∂' )

memberName
∂∂* 4
)
∂∂4 5
.
∂∂5 6
SingleOrDefault
∂∂6 E
(
∂∂E F
)
∂∂F G
;
∂∂G H
if
∏∏ 
(
∏∏ "
candidatePropertyDef
∏∏ (
!=
∏∏) +
null
∏∏, 0
)
∏∏0 1
{
ππ 
return
∫∫ "
candidatePropertyDef
∫∫ /
.
∫∫/ 0
	SetMethod
∫∫0 9
.
∫∫9 :!
ChangeDeclaringType
∫∫: M
(
∫∫M N
typeRef
∫∫N U
)
∫∫U V
;
∫∫V W
}
ªª 
}
ºº 
throw
ææ 
Assert
ææ 
.
ææ 
CreateException
ææ (
(
ææ( )
)
ææ) *
;
ææ* +
}
øø 	
FieldReference
¡¡ 
FindLocalField
¡¡ %
(
¡¡% &
TypeReference
¬¬ 
specificTypeRef
¬¬ )
,
¬¬) *
string
¬¬+ 1
	fieldName
¬¬2 ;
)
¬¬; <
{
√√ 	
foreach
ƒƒ 
(
ƒƒ 
var
ƒƒ 
typeRef
ƒƒ  
in
ƒƒ! #
specificTypeRef
ƒƒ$ 3
.
ƒƒ3 4)
GetSpecificBaseTypesAndSelf
ƒƒ4 O
(
ƒƒO P
)
ƒƒP Q
)
ƒƒQ R
{
≈≈ 
var
∆∆ 
candidateFieldDef
∆∆ %
=
∆∆& '
typeRef
∆∆( /
.
∆∆/ 0
Resolve
∆∆0 7
(
∆∆7 8
)
∆∆8 9
.
∆∆9 :
Fields
∆∆: @
.
«« 
Where
«« 
(
«« 
x
«« 
=>
«« 
x
««  !
.
««! "
Name
««" &
==
««' )
	fieldName
««* 3
)
««3 4
.
««4 5
SingleOrDefault
««5 D
(
««D E
)
««E F
;
««F G
if
…… 
(
…… 
candidateFieldDef
…… %
!=
……& (
null
……) -
)
……- .
{
   
return
ÀÀ 
candidateFieldDef
ÀÀ ,
.
ÀÀ, -!
ChangeDeclaringType
ÀÀ- @
(
ÀÀ@ A
typeRef
ÀÀA H
)
ÀÀH I
;
ÀÀI J
}
ÃÃ 
}
ÕÕ 
throw
œœ 
Assert
œœ 
.
œœ 
CreateException
œœ (
(
œœ( )
)
œœ) *
;
œœ* +
}
–– 	
bool
““  
TryFindLocalMethod
““ 
(
““  
TypeReference
”” 
specificTypeRef
”” )
,
””) *
string
””+ 1

methodName
””2 <
,
””< =
out
””> A
TypeReference
””B O
declaringTypeRef
””P `
,
””` a
out
””b e
MethodReference
””f u
	methodRef
””v 
)”” Ä
{
‘‘ 	
foreach
’’ 
(
’’ 
var
’’ 
typeRef
’’  
in
’’! #
specificTypeRef
’’$ 3
.
’’3 4)
GetSpecificBaseTypesAndSelf
’’4 O
(
’’O P
)
’’P Q
)
’’Q R
{
÷÷ 
var
◊◊  
candidateMethodDef
◊◊ &
=
◊◊' (
typeRef
◊◊) 0
.
◊◊0 1
Resolve
◊◊1 8
(
◊◊8 9
)
◊◊9 :
.
◊◊: ;
Methods
◊◊; B
.
ÿÿ 
Where
ÿÿ 
(
ÿÿ 
x
ÿÿ 
=>
ÿÿ 
x
ÿÿ  !
.
ÿÿ! "
Name
ÿÿ" &
==
ÿÿ' )

methodName
ÿÿ* 4
)
ÿÿ4 5
.
ÿÿ5 6
SingleOrDefault
ÿÿ6 E
(
ÿÿE F
)
ÿÿF G
;
ÿÿG H
if
⁄⁄ 
(
⁄⁄  
candidateMethodDef
⁄⁄ &
!=
⁄⁄' )
null
⁄⁄* .
)
⁄⁄. /
{
€€ 
declaringTypeRef
‹‹ $
=
‹‹% &
typeRef
‹‹' .
;
‹‹. /
	methodRef
›› 
=
››  
candidateMethodDef
››  2
.
››2 3!
ChangeDeclaringType
››3 F
(
››F G
typeRef
››G N
)
››N O
;
››O P
return
ﬁﬁ 
true
ﬁﬁ 
;
ﬁﬁ  
}
ﬂﬂ 
}
‡‡ 
declaringTypeRef
‚‚ 
=
‚‚ 
null
‚‚ #
;
‚‚# $
	methodRef
„„ 
=
„„ 
null
„„ 
;
„„ 
return
‰‰ 
false
‰‰ 
;
‰‰ 
}
ÂÂ 	
void
ÁÁ #
AddObjectInstructions
ÁÁ "
(
ÁÁ" #
List
ËË 
<
ËË 
Instruction
ËË 
>
ËË 
instructions
ËË *
,
ËË* +
object
ÈÈ 

identifier
ÈÈ 
)
ÈÈ 
{
ÍÍ 	
if
ÎÎ 
(
ÎÎ 

identifier
ÎÎ 
==
ÎÎ 
null
ÎÎ "
)
ÎÎ" #
{
ÏÏ 
instructions
ÌÌ 
.
ÌÌ 
Add
ÌÌ  
(
ÌÌ  !
Instruction
ÌÌ! ,
.
ÌÌ, -
Create
ÌÌ- 3
(
ÌÌ3 4
OpCodes
ÌÌ4 ;
.
ÌÌ; <
Ldnull
ÌÌ< B
)
ÌÌB C
)
ÌÌC D
;
ÌÌD E
}
ÓÓ 
else
ÔÔ 
if
ÔÔ 
(
ÔÔ 

identifier
ÔÔ 
is
ÔÔ  "
string
ÔÔ# )
)
ÔÔ) *
{
 
instructions
ÒÒ 
.
ÒÒ 
Add
ÒÒ  
(
ÒÒ  !
Instruction
ÒÒ! ,
.
ÒÒ, -
Create
ÒÒ- 3
(
ÒÒ3 4
OpCodes
ÒÒ4 ;
.
ÒÒ; <
Ldstr
ÒÒ< A
,
ÒÒA B
(
ÒÒC D
string
ÒÒD J
)
ÒÒJ K

identifier
ÒÒK U
)
ÒÒU V
)
ÒÒV W
;
ÒÒW X
}
ÚÚ 
else
ÛÛ 
if
ÛÛ 
(
ÛÛ 

identifier
ÛÛ 
is
ÛÛ  "
int
ÛÛ# &
)
ÛÛ& '
{
ÙÙ 
instructions
ıı 
.
ıı 
Add
ıı  
(
ıı  !
Instruction
ıı! ,
.
ıı, -
Create
ıı- 3
(
ıı3 4
OpCodes
ıı4 ;
.
ıı; <
Ldc_I4
ıı< B
,
ııB C
(
ııD E
int
ııE H
)
ııH I

identifier
ııI S
)
ııS T
)
ııT U
;
ııU V
instructions
ˆˆ 
.
ˆˆ 
Add
ˆˆ  
(
ˆˆ  !
Instruction
ˆˆ! ,
.
ˆˆ, -
Create
ˆˆ- 3
(
ˆˆ3 4
OpCodes
ˆˆ4 ;
.
ˆˆ; <
Box
ˆˆ< ?
,
ˆˆ? @
_module
ˆˆA H
.
ˆˆH I
Import
ˆˆI O
(
ˆˆO P
typeof
ˆˆP V
(
ˆˆV W
int
ˆˆW Z
)
ˆˆZ [
)
ˆˆ[ \
)
ˆˆ\ ]
)
ˆˆ] ^
;
ˆˆ^ _
}
˜˜ 
else
¯¯ 
if
¯¯ 
(
¯¯ 

identifier
¯¯ 
.
¯¯  
GetType
¯¯  '
(
¯¯' (
)
¯¯( )
.
¯¯) *
IsEnum
¯¯* 0
)
¯¯0 1
{
˘˘ 
instructions
˙˙ 
.
˙˙ 
Add
˙˙  
(
˙˙  !
Instruction
˙˙! ,
.
˙˙, -
Create
˙˙- 3
(
˙˙3 4
OpCodes
˙˙4 ;
.
˙˙; <
Ldc_I4
˙˙< B
,
˙˙B C
(
˙˙D E
int
˙˙E H
)
˙˙H I

identifier
˙˙I S
)
˙˙S T
)
˙˙T U
;
˙˙U V
instructions
˚˚ 
.
˚˚ 
Add
˚˚  
(
˚˚  !
Instruction
˚˚! ,
.
˚˚, -
Create
˚˚- 3
(
˚˚3 4
OpCodes
˚˚4 ;
.
˚˚; <
Box
˚˚< ?
,
˚˚? @
_module
˚˚A H
.
˚˚H I
Import
˚˚I O
(
˚˚O P

identifier
˚˚P Z
.
˚˚Z [
GetType
˚˚[ b
(
˚˚b c
)
˚˚c d
)
˚˚d e
)
˚˚e f
)
˚˚f g
;
˚˚g h
}
¸¸ 
else
˝˝ 
{
˛˛ 
throw
ˇˇ 
Assert
ˇˇ 
.
ˇˇ 
CreateException
ˇˇ ,
(
ˇˇ, -
$strÄÄ é
,ÄÄé è

identifierÄÄê ö
.ÄÄö õ
GetTypeÄÄõ ¢
(ÄÄ¢ £
)ÄÄ£ §
)ÄÄ§ •
;ÄÄ• ¶
}
ÅÅ 
}
ÇÇ 	
TypeReference
ÑÑ .
 CreateGenericInstanceIfNecessary
ÑÑ 6
(
ÑÑ6 7
Type
ÖÖ 

memberType
ÖÖ 
,
ÖÖ 

Collection
ÖÖ '
<
ÖÖ' (
GenericParameter
ÖÖ( 8
>
ÖÖ8 9
genericParams
ÖÖ: G
)
ÖÖG H
{
ÜÜ 	
if
áá 
(
áá 
!
áá 

memberType
áá 
.
áá '
ContainsGenericParameters
áá 5
)
áá5 6
{
àà 
return
ââ 
_module
ââ 
.
ââ 
Import
ââ %
(
ââ% &

memberType
ââ& 0
)
ââ0 1
;
ââ1 2
}
ää 
if
åå 
(
åå 

memberType
åå 
.
åå  
IsGenericParameter
åå -
)
åå- .
{
çç 
return
éé 
genericParams
éé $
[
éé$ %

memberType
éé% /
.
éé/ 0&
GenericParameterPosition
éé0 H
]
ééH I
;
ééI J
}
èè 
if
ëë 
(
ëë 

memberType
ëë 
.
ëë 
IsArray
ëë "
)
ëë" #
{
íí 
return
ìì 
new
ìì 
	ArrayType
ìì $
(
ìì$ %.
 CreateGenericInstanceIfNecessary
îî 4
(
îî4 5

memberType
îî5 ?
.
îî? @
GetElementType
îî@ N
(
îîN O
)
îîO P
,
îîP Q
genericParams
îîR _
)
îî_ `
,
îî` a

memberType
îîb l
.
îîl m
GetArrayRank
îîm y
(
îîy z
)
îîz {
)
îî{ |
;
îî| }
}
ïï 
var
óó 
genericMemberType
óó !
=
óó" #

memberType
óó$ .
.
óó. /&
GetGenericTypeDefinition
óó/ G
(
óóG H
)
óóH I
;
óóI J
var
ôô 
genericInstance
ôô 
=
ôô  !
new
ôô" %!
GenericInstanceType
ôô& 9
(
ôô9 :
_module
ôô: A
.
ôôA B
Import
ôôB H
(
ôôH I
genericMemberType
ôôI Z
)
ôôZ [
)
ôô[ \
;
ôô\ ]
foreach
õõ 
(
õõ 
var
õõ 
arg
õõ 
in
õõ 

memberType
õõ  *
.
õõ* +
GenericArguments
õõ+ ;
(
õõ; <
)
õõ< =
)
õõ= >
{
úú 
genericInstance
ùù 
.
ùù  
GenericArguments
ùù  0
.
ùù0 1
Add
ùù1 4
(
ùù4 5.
 CreateGenericInstanceIfNecessary
ûû 4
(
ûû4 5
arg
ûû5 8
,
ûû8 9
genericParams
ûû: G
)
ûûG H
)
ûûH I
;
ûûI J
}
üü 
return
°° 
genericInstance
°° "
;
°°" #
}
¢¢ 	
void
§§ -
AddInjectableMemberInstructions
§§ ,
(
§§, -
List
•• 
<
•• 
Instruction
•• 
>
•• 
instructions
•• *
,
••* +
InjectableInfo
¶¶ 
injectableInfo
¶¶ )
,
¶¶) *
string
¶¶+ 1
name
¶¶2 6
,
¶¶6 7
TypeDefinition
ßß 
typeDef
ßß "
,
ßß" #
TypeReference
ßß$ 1
genericTypeDef
ßß2 @
,
ßß@ A
MethodDefinition
®® 
	methodDef
®® &
)
®®& '
{
©© 	
instructions
™™ 
.
™™ 
Add
™™ 
(
™™ 
Instruction
™™ (
.
™™( )
Create
™™) /
(
™™/ 0
OpCodes
™™0 7
.
™™7 8
Ldnull
™™8 >
)
™™> ?
)
™™? @
;
™™@ A
instructions
´´ 
.
´´ 
Add
´´ 
(
´´ 
Instruction
´´ (
.
´´( )
Create
´´) /
(
´´/ 0
OpCodes
´´0 7
.
´´7 8
Ldftn
´´8 =
,
´´= >
	methodDef
´´? H
.
´´H I!
ChangeDeclaringType
´´I \
(
´´\ ]
genericTypeDef
´´] k
)
´´k l
)
´´l m
)
´´m n
;
´´n o
instructions
¨¨ 
.
¨¨ 
Add
¨¨ 
(
¨¨ 
Instruction
¨¨ (
.
¨¨( )
Create
¨¨) /
(
¨¨/ 0
OpCodes
¨¨0 7
.
¨¨7 8
Newobj
¨¨8 >
,
¨¨> ?
_funcMemberSetter
¨¨@ Q
)
¨¨Q R
)
¨¨R S
;
¨¨S T/
!EmitNewInjectableInfoInstructions
ÆÆ -
(
ÆÆ- .
instructions
ØØ 
,
ØØ 
injectableInfo
ØØ ,
,
ØØ, -
typeDef
ØØ. 5
)
ØØ5 6
;
ØØ6 7
instructions
±± 
.
±± 
Add
±± 
(
±± 
Instruction
±± (
.
±±( )
Create
±±) /
(
±±/ 0
OpCodes
±±0 7
.
±±7 8
Newobj
±±8 >
,
±±> ?*
_injectMemberInfoConstructor
±±@ \
)
±±\ ]
)
±±] ^
;
±±^ _
}
≤≤ 	
void
¥¥ -
AddInjectableMethodInstructions
¥¥ ,
(
¥¥, -
List
µµ 
<
µµ 
Instruction
µµ 
>
µµ 
instructions
µµ *
,
µµ* + 
ReflectionTypeInfo
∂∂ 
.
∂∂ 
InjectMethodInfo
∂∂ /
injectMethod
∂∂0 <
,
∂∂< =
TypeDefinition
∑∑ 
typeDef
∑∑ "
,
∑∑" #
TypeReference
∑∑$ 1
genericTypeDef
∑∑2 @
,
∑∑@ A
MethodDefinition
∏∏ 
	methodDef
∏∏ &
)
∏∏& '
{
ππ 	
instructions
∫∫ 
.
∫∫ 
Add
∫∫ 
(
∫∫ 
Instruction
∫∫ (
.
∫∫( )
Create
∫∫) /
(
∫∫/ 0
OpCodes
∫∫0 7
.
∫∫7 8
Ldnull
∫∫8 >
)
∫∫> ?
)
∫∫? @
;
∫∫@ A
instructions
ªª 
.
ªª 
Add
ªª 
(
ªª 
Instruction
ªª (
.
ªª( )
Create
ªª) /
(
ªª/ 0
OpCodes
ªª0 7
.
ªª7 8
Ldftn
ªª8 =
,
ªª= >
	methodDef
ªª? H
.
ªªH I!
ChangeDeclaringType
ªªI \
(
ªª\ ]
genericTypeDef
ªª] k
)
ªªk l
)
ªªl m
)
ªªm n
;
ªªn o
instructions
ºº 
.
ºº 
Add
ºº 
(
ºº 
Instruction
ºº (
.
ºº( )
Create
ºº) /
(
ºº/ 0
OpCodes
ºº0 7
.
ºº7 8
Newobj
ºº8 >
,
ºº> ?
_funcPostInject
ºº@ O
)
ººO P
)
ººP Q
;
ººQ R
instructions
ææ 
.
ææ 
Add
ææ 
(
ææ 
Instruction
ææ (
.
ææ( )
Create
ææ) /
(
ææ/ 0
OpCodes
ææ0 7
.
ææ7 8
Ldc_I4
ææ8 >
,
ææ> ?
injectMethod
ææ@ L
.
ææL M

Parameters
ææM W
.
ææW X
Count
ææX ]
)
ææ] ^
)
ææ^ _
;
ææ_ `
instructions
øø 
.
øø 
Add
øø 
(
øø 
Instruction
øø (
.
øø( )
Create
øø) /
(
øø/ 0
OpCodes
øø0 7
.
øø7 8
Newarr
øø8 >
,
øø> ?!
_injectableInfoType
øø@ S
)
øøS T
)
øøT U
;
øøU V
for
¡¡ 
(
¡¡ 
int
¡¡ 
i
¡¡ 
=
¡¡ 
$num
¡¡ 
;
¡¡ 
i
¡¡ 
<
¡¡ 
injectMethod
¡¡  ,
.
¡¡, -

Parameters
¡¡- 7
.
¡¡7 8
Count
¡¡8 =
;
¡¡= >
i
¡¡? @
++
¡¡@ B
)
¡¡B C
{
¬¬ 
var
√√ 
injectableInfo
√√ "
=
√√# $
injectMethod
√√% 1
.
√√1 2

Parameters
√√2 <
[
√√< =
i
√√= >
]
√√> ?
.
√√? @
InjectableInfo
√√@ N
;
√√N O
instructions
≈≈ 
.
≈≈ 
Add
≈≈  
(
≈≈  !
Instruction
≈≈! ,
.
≈≈, -
Create
≈≈- 3
(
≈≈3 4
OpCodes
≈≈4 ;
.
≈≈; <
Dup
≈≈< ?
)
≈≈? @
)
≈≈@ A
;
≈≈A B
instructions
∆∆ 
.
∆∆ 
Add
∆∆  
(
∆∆  !
Instruction
∆∆! ,
.
∆∆, -
Create
∆∆- 3
(
∆∆3 4
OpCodes
∆∆4 ;
.
∆∆; <
Ldc_I4
∆∆< B
,
∆∆B C
i
∆∆D E
)
∆∆E F
)
∆∆F G
;
∆∆G H/
!EmitNewInjectableInfoInstructions
»» 1
(
»»1 2
instructions
……  
,
……  !
injectableInfo
……" 0
,
……0 1
typeDef
……2 9
)
……9 :
;
……: ;
instructions
ÀÀ 
.
ÀÀ 
Add
ÀÀ  
(
ÀÀ  !
Instruction
ÀÀ! ,
.
ÀÀ, -
Create
ÀÀ- 3
(
ÀÀ3 4
OpCodes
ÀÀ4 ;
.
ÀÀ; <

Stelem_Ref
ÀÀ< F
)
ÀÀF G
)
ÀÀG H
;
ÀÀH I
}
ÃÃ 
instructions
ŒŒ 
.
ŒŒ 
Add
ŒŒ 
(
ŒŒ 
Instruction
ŒŒ (
.
ŒŒ( )
Create
ŒŒ) /
(
ŒŒ/ 0
OpCodes
ŒŒ0 7
.
ŒŒ7 8
Ldstr
ŒŒ8 =
,
ŒŒ= >
injectMethod
ŒŒ? K
.
ŒŒK L

MethodInfo
ŒŒL V
.
ŒŒV W
Name
ŒŒW [
)
ŒŒ[ \
)
ŒŒ\ ]
;
ŒŒ] ^
instructions
–– 
.
–– 
Add
–– 
(
–– 
Instruction
–– (
.
––( )
Create
––) /
(
––/ 0
OpCodes
––0 7
.
––7 8
Newobj
––8 >
,
––> ?*
_injectMethodInfoConstructor
––@ \
)
––\ ]
)
––] ^
;
––^ _
}
—— 	
void
”” /
!EmitNewInjectableInfoInstructions
”” .
(
””. /
List
‘‘ 
<
‘‘ 
Instruction
‘‘ 
>
‘‘ 
instructions
‘‘ *
,
‘‘* +
InjectableInfo
’’ 
injectableInfo
’’ )
,
’’) *
TypeDefinition
÷÷ 
typeDef
÷÷ "
)
÷÷" #
{
◊◊ 	
if
ÿÿ 
(
ÿÿ 
injectableInfo
ÿÿ 
.
ÿÿ 
Optional
ÿÿ '
)
ÿÿ' (
{
ŸŸ 
instructions
⁄⁄ 
.
⁄⁄ 
Add
⁄⁄  
(
⁄⁄  !
Instruction
⁄⁄! ,
.
⁄⁄, -
Create
⁄⁄- 3
(
⁄⁄3 4
OpCodes
⁄⁄4 ;
.
⁄⁄; <
Ldc_I4_1
⁄⁄< D
)
⁄⁄D E
)
⁄⁄E F
;
⁄⁄F G
}
€€ 
else
‹‹ 
{
›› 
instructions
ﬁﬁ 
.
ﬁﬁ 
Add
ﬁﬁ  
(
ﬁﬁ  !
Instruction
ﬁﬁ! ,
.
ﬁﬁ, -
Create
ﬁﬁ- 3
(
ﬁﬁ3 4
OpCodes
ﬁﬁ4 ;
.
ﬁﬁ; <
Ldc_I4_0
ﬁﬁ< D
)
ﬁﬁD E
)
ﬁﬁE F
;
ﬁﬁF G
}
ﬂﬂ #
AddObjectInstructions
·· !
(
··! "
instructions
··" .
,
··. /
injectableInfo
··0 >
.
··> ?

Identifier
··? I
)
··I J
;
··J K
instructions
„„ 
.
„„ 
Add
„„ 
(
„„ 
Instruction
„„ (
.
„„( )
Create
„„) /
(
„„/ 0
OpCodes
„„0 7
.
„„7 8
Ldstr
„„8 =
,
„„= >
injectableInfo
„„? M
.
„„M N

MemberName
„„N X
)
„„X Y
)
„„Y Z
;
„„Z [
instructions
ÂÂ 
.
ÂÂ 
Add
ÂÂ 
(
ÂÂ 
Instruction
ÂÂ (
.
ÂÂ( )
Create
ÂÂ) /
(
ÂÂ/ 0
OpCodes
ÂÂ0 7
.
ÂÂ7 8
Ldtoken
ÂÂ8 ?
,
ÂÂ? @.
 CreateGenericInstanceIfNecessary
ÂÂA a
(
ÂÂa b
injectableInfo
ÂÂb p
.
ÂÂp q

MemberType
ÂÂq {
,
ÂÂ{ |
typeDefÂÂ} Ñ
.ÂÂÑ Ö!
GenericParametersÂÂÖ ñ
)ÂÂñ ó
)ÂÂó ò
)ÂÂò ô
;ÂÂô ö
instructions
ÁÁ 
.
ÁÁ 
Add
ÁÁ 
(
ÁÁ 
Instruction
ÁÁ (
.
ÁÁ( )
Create
ÁÁ) /
(
ÁÁ/ 0
OpCodes
ÁÁ0 7
.
ÁÁ7 8
Call
ÁÁ8 <
,
ÁÁ< =&
_getTypeFromHandleMethod
ÁÁ> V
)
ÁÁV W
)
ÁÁW X
;
ÁÁX Y#
AddObjectInstructions
ÈÈ !
(
ÈÈ! "
instructions
ÈÈ" .
,
ÈÈ. /
injectableInfo
ÈÈ0 >
.
ÈÈ> ?
DefaultValue
ÈÈ? K
)
ÈÈK L
;
ÈÈL M
instructions
ÎÎ 
.
ÎÎ 
Add
ÎÎ 
(
ÎÎ 
Instruction
ÎÎ (
.
ÎÎ( )
Create
ÎÎ) /
(
ÎÎ/ 0
OpCodes
ÎÎ0 7
.
ÎÎ7 8
Ldc_I4
ÎÎ8 >
,
ÎÎ> ?
(
ÎÎ@ A
int
ÎÎA D
)
ÎÎD E
injectableInfo
ÎÎE S
.
ÎÎS T

SourceType
ÎÎT ^
)
ÎÎ^ _
)
ÎÎ_ `
;
ÎÎ` a
instructions
ÌÌ 
.
ÌÌ 
Add
ÌÌ 
(
ÌÌ 
Instruction
ÌÌ (
.
ÌÌ( )
Create
ÌÌ) /
(
ÌÌ/ 0
OpCodes
ÌÌ0 7
.
ÌÌ7 8
Newobj
ÌÌ8 >
,
ÌÌ> ?(
_injectableInfoConstructor
ÌÌ@ Z
)
ÌÌZ [
)
ÌÌ[ \
;
ÌÌ\ ]
}
ÓÓ 	
}
ÔÔ 
} ™
{C:\Users\–ö–ª–∏–º–Ω—é–∫\tring\App\Assets\Plugins\Zenject\OptionalExtras\ReflectionBaking\Unity\ReflectionBakingMenuItems.cs
	namespace 	
Zenject
 
. 
ReflectionBaking "
{		 
public

 

static

 
class

 %
ReflectionBakingMenuItems

 1
{ 
[ 	
MenuItem	 
( 
$str D
,D E
falseF K
,K L
$numM P
)P Q
]Q R
public 
static 
void *
CreateReflectionBakingSettings 9
(9 :
): ;
{ 	
var 

folderPath 
= 
ZenUnityEditorUtil /
./ 05
)GetCurrentDirectoryAssetPathFromSelection0 Y
(Y Z
)Z [
;[ \
var 
config 
= 
ScriptableObject )
.) *
CreateInstance* 8
<8 9+
ZenjectReflectionBakingSettings9 X
>X Y
(Y Z
)Z [
;[ \
ZenUnityEditorUtil 
. %
SaveScriptableObjectAsset 8
(8 9
Path 
. 
Combine 
( 

folderPath '
,' (
$str) P
)P Q
,Q R
configS Y
)Y Z
;Z [
} 	
} 
} ¶/
~C:\Users\–ö–ª–∏–º–Ω—é–∫\tring\App\Assets\Plugins\Zenject\OptionalExtras\ReflectionBaking\Unity\ReflectionBakingInternalUtil.cs
	namespace 	
Zenject
 
. 
ReflectionBaking "
{		 
public

 

static

 
class

 (
ReflectionBakingInternalUtil

 4
{ 
public 
static 
string (
ConvertAssetPathToSystemPath 9
(9 :
string: @
	assetPathA J
)J K
{ 	
string 
path 
= 
Application %
.% &
dataPath& .
;. /
int 

pathLength 
= 
path !
.! "
Length" (
;( )
path 
= 
path 
. 
	Substring !
(! "
$num" #
,# $

pathLength% /
-0 1
$num? @
)@ A
;A B
path 
= 
Path 
. 
Combine 
(  
path  $
,$ %
	assetPath& /
)/ 0
;0 1
return 
path 
; 
} 	
public 
static +
ZenjectReflectionBakingSettings 5)
TryGetEnabledSettingsInstance6 S
(S T
)T U
{ 	
string 
[ 
] 
guids 
= 
AssetDatabase *
.* +

FindAssets+ 5
(5 6
$str6 Y
)Y Z
;Z [
if 
( 
guids 
. 
IsEmpty 
( 
) 
)  
{ 
return 
null 
; 
} +
ZenjectReflectionBakingSettings +
enabledSettings, ;
=< =
null> B
;B C
foreach   
(   
var   
guid   
in    
guids  ! &
)  & '
{!! 
var"" 
	candidate"" 
="" 
AssetDatabase""  -
.""- .
LoadAssetAtPath"". =
<""= >+
ZenjectReflectionBakingSettings""> ]
>""] ^
(""^ _
AssetDatabase## !
.##! "
GUIDToAssetPath##" 1
(##1 2
guid##2 6
)##6 7
)##7 8
;##8 9
if%% 
(%% 
(%% 
Application%%  
.%%  !
isEditor%%! )
&&%%* ,
	candidate%%- 6
.%%6 7
IsEnabledInEditor%%7 H
)%%H I
||%%J L
(%%M N
BuildPipeline%%N [
.%%[ \
isBuildingPlayer%%\ l
&&%%m o
	candidate%%p y
.%%y z
IsEnabledInBuilds	%%z ã
)
%%ã å
)
%%å ç
{&& 
Assert'' 
.'' 
IsNull'' !
(''! "
enabledSettings''" 1
,''1 2
$str	''3 ú
)
''ú ù
;
''ù û
enabledSettings(( #
=(($ %
	candidate((& /
;((/ 0
})) 
}** 
return,, 
enabledSettings,, "
;,," #
}-- 	
public// 
static// 
string// &
ConvertAbsoluteToAssetPath// 7
(//7 8
string//8 >

systemPath//? I
)//I J
{00 	
var11 
projectPath11 
=11 
Application11 )
.11) *
dataPath11* 2
;112 3
projectPath44 
=44 
projectPath44 %
.44% &
	Substring44& /
(44/ 0
$num440 1
,441 2
projectPath443 >
.44> ?
Length44? E
-44F G
$num44U V
)44V W
;44W X
int66 
systemPathLength66  
=66! "

systemPath66# -
.66- .
Length66. 4
;664 5
int77 
assetPathLength77 
=77  !
systemPathLength77" 2
-773 4
projectPath775 @
.77@ A
Length77A G
;77G H
Assert99 
.99 
That99 
(99 
assetPathLength99 '
>99( )
$num99* +
,99+ ,
$str99- B
,99B C

systemPath99D N
)99N O
;99O P
return;; 

systemPath;; 
.;; 
	Substring;; '
(;;' (
projectPath;;( 3
.;;3 4
Length;;4 :
,;;: ;
assetPathLength;;< K
);;K L
;;;L M
}<< 	
public>> 
static>> 
void>> $
TryForceUnityFullCompile>> 3
(>>3 4
)>>4 5
{?? 	
Type@@ 
compInterface@@ 
=@@  
typeof@@! '
(@@' (
UnityEditor@@( 3
.@@3 4
Editor@@4 :
)@@: ;
.@@; <
Assembly@@< D
.@@D E
GetType@@E L
(@@L M
$strAA T
)AAT U
;AAU V
ifCC 
(CC 
compInterfaceCC 
!=CC  
nullCC! %
)CC% &
{DD 
varEE !
dirtyAllScriptsMethodEE )
=EE* +
compInterfaceEE, 9
.EE9 :
	GetMethodEE: C
(EEC D
$strFF %
,FF% &
BindingFlagsFF' 3
.FF3 4
StaticFF4 :
|FF; <
BindingFlagsFF= I
.FFI J
PublicFFJ P
|FFQ R
BindingFlagsFFS _
.FF_ `
	NonPublicFF` i
)FFi j
;FFj k!
dirtyAllScriptsMethodHH %
.HH% &
InvokeHH& ,
(HH, -
nullHH- 1
,HH1 2
nullHH3 7
)HH7 8
;HH8 9
}II 
UnityEditorKK 
.KK 
AssetDatabaseKK %
.KK% &
RefreshKK& -
(KK- .
)KK. /
;KK/ 0
}LL 	
}MM 
}NN Ì$
vC:\Users\–ö–ª–∏–º–Ω—é–∫\tring\App\Assets\Plugins\Zenject\OptionalExtras\ReflectionBaking\Unity\AssemblyPathRegistry.cs
	namespace 	
Zenject
 
. 
ReflectionBaking "
{		 
public

 

class

  
AssemblyPathRegistry

 %
{ 
static 
List 
< 
string 
> 
_assemblies '
;' (
public 
static 
List 
< 
string !
>! "0
$GetAllGeneratedAssemblyRelativePaths# G
(G H
)H I
{ 	
if 
( 
_assemblies 
== 
null #
)# $
{ 
_assemblies 
= +
LookupAllGeneratedAssemblyPaths =
(= >
)> ?
;? @
Assert 
. 
	IsNotNull  
(  !
_assemblies! ,
), -
;- .
} 
return 
_assemblies 
; 
} 	
static 
bool 
IsManagedAssembly %
(% &
string& ,

systemPath- 7
)7 8
{ 	
DllType 
dllType 
= !
InternalEditorUtility 3
.3 4
DetectDotNetDll4 C
(C D

systemPathD N
)N O
;O P
return 
dllType 
!= 
DllType %
.% &
Unknown& -
&&. 0
dllType1 8
!=9 ;
DllType< C
.C D
NativeD J
;J K
} 	
static 
List 
< 
string 
> +
LookupAllGeneratedAssemblyPaths ;
(; <
)< =
{   	
var!! 

assemblies!! 
=!! 
new!!  
List!!! %
<!!% &
string!!& ,
>!!, -
(!!- .
$num!!. 0
)!!0 1
;!!1 2
FindAssemblies&& 
(&& 
Application&& &
.&&& '
dataPath&&' /
+&&0 1
$str&&2 Q
,&&Q R
$num&&S T
,&&T U

assemblies&&V `
)&&` a
;&&a b
return(( 

assemblies(( 
;(( 
})) 	
public++ 
static++ 
void++ 
FindAssemblies++ )
(++) *
string++* 0

systemPath++1 ;
,++; <
int++= @
maxDepth++A I
,++I J
List++K O
<++O P
string++P V
>++V W
result++X ^
)++^ _
{,, 	
if-- 
(-- 
maxDepth-- 
>-- 
$num-- 
)-- 
{.. 
if// 
(// 
	Directory// 
.// 
Exists// $
(//$ %

systemPath//% /
)/// 0
)//0 1
{00 
var11 
dirInfo11 
=11  !
new11" %
DirectoryInfo11& 3
(113 4

systemPath114 >
)11> ?
;11? @
result33 
.33 
AddRange33 #
(33# $
dirInfo44 
.44  
GetFiles44  (
(44( )
)44) *
.44* +
Select44+ 1
(441 2
x442 3
=>444 6
x447 8
.448 9
FullName449 A
)44A B
.55 
Where55 
(55 
IsManagedAssembly55 0
)550 1
.66 
Select66 
(66  (
ReflectionBakingInternalUtil66  <
.66< =&
ConvertAbsoluteToAssetPath66= W
)66W X
)66X Y
;66Y Z
var88 
directories88 #
=88$ %
dirInfo88& -
.88- .
GetDirectories88. <
(88< =
)88= >
;88> ?
for:: 
(:: 
int:: 
i:: 
=::  
$num::! "
;::" #
i::$ %
<::& '
directories::( 3
.::3 4
Length::4 :
;::: ;
i::< =
++::= ?
)::? @
{;; 
DirectoryInfo<< %
current<<& -
=<<. /
directories<<0 ;
[<<; <
i<<< =
]<<= >
;<<> ?
FindAssemblies>> &
(>>& '
current>>' .
.>>. /
FullName>>/ 7
,>>7 8
maxDepth>>9 A
->>B C
$num>>D E
,>>E F
result>>G M
)>>M N
;>>N O
}?? 
}@@ 
}AA 
}BB 	
}CC 
}DD À5
wC:\Users\–ö–ª–∏–º–Ω—é–∫\tring\App\Assets\Plugins\Zenject\OptionalExtras\ReflectionBaking\Unity\UnityAssemblyResolver.cs
	namespace 	
Zenject
 
. 
ReflectionBaking "
{ 
public		 

class		 !
UnityAssemblyResolver		 &
:		' ( 
BaseAssemblyResolver		) =
{

 
readonly 
IDictionary 
< 
string #
,# $
string% +
>+ ,'
_appDomainAssemblyLocations- H
;H I
readonly 
IDictionary 
< 
string #
,# $
AssemblyDefinition% 7
>7 8
_cache9 ?
;? @
public !
UnityAssemblyResolver $
($ %
)% &
{ 	'
_appDomainAssemblyLocations '
=( )
new* -

Dictionary. 8
<8 9
string9 ?
,? @
stringA G
>G H
(H I
)I J
;J K
_cache 
= 
new 

Dictionary #
<# $
string$ *
,* +
AssemblyDefinition, >
>> ?
(? @
)@ A
;A B
	AppDomain 
domain 
= 
	AppDomain (
.( )
CurrentDomain) 6
;6 7
Assembly 
[ 
] 

assemblies !
=" #
domain$ *
.* +
GetAssemblies+ 8
(8 9
)9 :
;: ;
for 
( 
int 
i 
= 
$num 
; 
i 
< 

assemblies  *
.* +
Length+ 1
;1 2
i3 4
++4 6
)6 7
{ 
if 
( 

assemblies 
[ 
i  
]  !
.! "
	IsDynamic" +
)+ ,
{ 
continue 
; 
} '
_appDomainAssemblyLocations   +
[  + ,

assemblies  , 6
[  6 7
i  7 8
]  8 9
.  9 :
FullName  : B
]  B C
=  D E

assemblies  F P
[  P Q
i  Q R
]  R S
.  S T
Location  T \
;  \ ]
AddSearchDirectory"" "
(""" #
Path""# '
.""' (
GetDirectoryName""( 8
(""8 9

assemblies""9 C
[""C D
i""D E
]""E F
.""F G
Location""G O
)""O P
)""P Q
;""Q R
}## 
}$$ 	
public&& 
override&& 
AssemblyDefinition&& *
Resolve&&+ 2
(&&2 3!
AssemblyNameReference&&3 H
name&&I M
)&&M N
{'' 	
AssemblyDefinition(( 
assemblyDef(( *
=((+ ,"
FindAssemblyDefinition((- C
(((C D
name((D H
.((H I
FullName((I Q
,((Q R
null((S W
)((W X
;((X Y
if** 
(** 
assemblyDef** 
==** 
null** #
)**# $
{++ 
assemblyDef,, 
=,, 
base,, "
.,," #
Resolve,,# *
(,,* +
name,,+ /
),,/ 0
;,,0 1
_cache-- 
[-- 
name-- 
.-- 
FullName-- $
]--$ %
=--& '
assemblyDef--( 3
;--3 4
}.. 
return00 
assemblyDef00 
;00 
}11 	
public33 
override33 
AssemblyDefinition33 *
Resolve33+ 2
(332 3!
AssemblyNameReference333 H
name33I M
,33M N
ReaderParameters33O _

parameters33` j
)33j k
{44 	
AssemblyDefinition55 
assemblyDef55 *
=55+ ,"
FindAssemblyDefinition55- C
(55C D
name55D H
.55H I
FullName55I Q
,55Q R

parameters55S ]
)55] ^
;55^ _
if77 
(77 
assemblyDef77 
==77 
null77 #
)77# $
{88 
assemblyDef99 
=99 
base99 "
.99" #
Resolve99# *
(99* +
name99+ /
,99/ 0

parameters991 ;
)99; <
;99< =
_cache:: 
[:: 
name:: 
.:: 
FullName:: $
]::$ %
=::& '
assemblyDef::( 3
;::3 4
};; 
return== 
assemblyDef== 
;== 
}>> 	
AssemblyDefinitionBB "
FindAssemblyDefinitionBB 1
(BB1 2
stringBB2 8
fullNameBB9 A
,BBA B
ReaderParametersBBC S

parametersBBT ^
)BB^ _
{CC 	
ifDD 
(DD 
fullNameDD 
==DD 
nullDD  
)DD  !
{EE 
throwFF 
newFF !
ArgumentNullExceptionFF /
(FF/ 0
$strFF0 :
)FF: ;
;FF; <
}GG 
AssemblyDefinitionII 
assemblyDefinitionII 1
;II1 2
ifLL 
(LL 
_cacheLL 
.LL 
TryGetValueLL "
(LL" #
fullNameLL# +
,LL+ ,
outLL- 0
assemblyDefinitionLL1 C
)LLC D
)LLD E
{MM 
returnNN 
assemblyDefinitionNN )
;NN) *
}OO 
stringSS 
locationSS 
;SS 
ifUU 
(UU '
_appDomainAssemblyLocationsUU +
.UU+ ,
TryGetValueUU, 7
(UU7 8
fullNameUU8 @
,UU@ A
outUUB E
locationUUF N
)UUN O
)UUO P
{VV 
ifWW 
(WW 

parametersWW 
!=WW !
nullWW" &
)WW& '
{XX 
assemblyDefinitionYY &
=YY' (
AssemblyDefinitionYY) ;
.YY; <
ReadAssemblyYY< H
(YYH I
locationYYI Q
,YYQ R

parametersYYS ]
)YY] ^
;YY^ _
}ZZ 
else[[ 
{\\ 
assemblyDefinition]] &
=]]' (
AssemblyDefinition]]) ;
.]]; <
ReadAssembly]]< H
(]]H I
location]]I Q
)]]Q R
;]]R S
}^^ 
_cache`` 
[`` 
fullName`` 
]``  
=``! "
assemblyDefinition``# 5
;``5 6
returnbb 
assemblyDefinitionbb )
;bb) *
}cc 
returnee 
nullee 
;ee 
}ff 	
}gg 
}hh Õë
áC:\Users\–ö–ª–∏–º–Ω—é–∫\tring\App\Assets\Plugins\Zenject\OptionalExtras\ReflectionBaking\Unity\ZenjectReflectionBakingSettingsEditor.cs
	namespace 	
Zenject
 
. 
ReflectionBaking "
{ 
[ 
CustomEditor 
( 
typeof 
( +
ZenjectReflectionBakingSettings 8
)8 9
)9 :
]: ;
public 

class 1
%ZenjectReflectionBakingSettingsEditor 6
:7 8
Editor9 ?
{		 
SerializedProperty

 
_includeAssemblies

 -
;

- .
SerializedProperty 
_excludeAssemblies -
;- .
SerializedProperty 
_namespacePatterns -
;- .
SerializedProperty 
_isEnabledInBuilds -
;- .
SerializedProperty 
_isEnabledInEditor -
;- .
SerializedProperty #
_allGeneratedAssemblies 2
;2 3
ReorderableList "
_includeAssembliesList .
;. /
ReorderableList "
_excludeAssembliesList .
;. /
ReorderableList "
_namespacePatternsList .
;. /
Vector2 
_logScrollPosition "
;" #
int 
_selectedLogIndex 
; 
bool "
_hasModifiedProperties #
;# $
static 

GUIContent /
#_includeAssembliesListHeaderContent =
=> ?
new@ C

GUIContentD N
{ 	
text 
= 
$str '
,' (
tooltip 
= 
$str |
}   	
;  	 

static"" 

GUIContent"" /
#_excludeAssembliesListHeaderContent"" =
=""> ?
new""@ C

GUIContent""D N
{## 	
text$$ 
=$$ 
$str$$ '
,$$' (
tooltip%% 
=%% 
$str%% O
}&& 	
;&&	 

static(( 

GUIContent(( .
"_namespacePatternListHeaderContent(( <
=((= >
new((? B

GUIContent((C M
{)) 	
text** 
=** 
$str** '
,**' (
tooltip++ 
=++ 
$str	++ ÷
},, 	
;,,	 

void.. 
OnEnable.. 
(.. 
).. 
{// 	
_includeAssemblies00 
=00  
serializedObject00! 1
.001 2
FindProperty002 >
(00> ?
$str00? S
)00S T
;00T U
_excludeAssemblies11 
=11  
serializedObject11! 1
.111 2
FindProperty112 >
(11> ?
$str11? S
)11S T
;11T U
_namespacePatterns22 
=22  
serializedObject22! 1
.221 2
FindProperty222 >
(22> ?
$str22? S
)22S T
;22T U
_isEnabledInEditor33 
=33  
serializedObject33! 1
.331 2
FindProperty332 >
(33> ?
$str33? S
)33S T
;33T U
_isEnabledInBuilds44 
=44  
serializedObject44! 1
.441 2
FindProperty442 >
(44> ?
$str44? S
)44S T
;44T U#
_allGeneratedAssemblies55 #
=55$ %
serializedObject55& 6
.556 7
FindProperty557 C
(55C D
$str55D ]
)55] ^
;55^ _"
_namespacePatternsList77 "
=77# $
new77% (
ReorderableList77) 8
(778 9
serializedObject779 I
,77I J
_namespacePatterns77K ]
)77] ^
;77^ _"
_namespacePatternsList88 "
.88" #
drawHeaderCallback88# 5
+=886 8)
OnNamespacePatternsDrawHeader889 V
;88V W"
_namespacePatternsList99 "
.99" #
drawElementCallback99# 6
+=997 9*
OnNamespacePatternsDrawElement99: X
;99X Y"
_includeAssembliesList;; "
=;;# $
new;;% (
ReorderableList;;) 8
(;;8 9
serializedObject;;9 I
,;;I J
_includeAssemblies;;K ]
);;] ^
;;;^ _"
_includeAssembliesList<< "
.<<" #
drawHeaderCallback<<# 5
+=<<6 8-
!OnIncludeWeavedAssemblyDrawHeader<<9 Z
;<<Z ["
_includeAssembliesList== "
.==" #
onAddCallback==# 0
+===1 3/
#OnIncludeWeavedAssemblyElementAdded==4 W
;==W X"
_includeAssembliesList>> "
.>>" #
drawElementCallback>># 6
+=>>7 9,
 OnIncludeAssemblyListDrawElement>>: Z
;>>Z ["
_excludeAssembliesList@@ "
=@@# $
new@@% (
ReorderableList@@) 8
(@@8 9
serializedObject@@9 I
,@@I J
_excludeAssemblies@@K ]
)@@] ^
;@@^ _"
_excludeAssembliesListAA "
.AA" #
drawHeaderCallbackAA# 5
+=AA6 8-
!OnExcludeWeavedAssemblyDrawHeaderAA9 Z
;AAZ ["
_excludeAssembliesListBB "
.BB" #
onAddCallbackBB# 0
+=BB1 3/
#OnExcludeWeavedAssemblyElementAddedBB4 W
;BBW X"
_excludeAssembliesListCC "
.CC" #
drawElementCallbackCC# 6
+=CC7 9,
 OnExcludeAssemblyListDrawElementCC: Z
;CCZ [
}DD 	
voidFF *
OnNamespacePatternsDrawElementFF +
(FF+ ,
RectFF, 0
rectFF1 5
,FF5 6
intFF7 :
indexFF; @
,FF@ A
boolFFB F
isActiveFFG O
,FFO P
boolFFQ U
	isFocusedFFV _
)FF_ `
{GG 	
SerializedPropertyHH 
indexPropertyHH ,
=HH- .
_namespacePatternsHH/ A
.HHA B"
GetArrayElementAtIndexHHB X
(HHX Y
indexHHY ^
)HH^ _
;HH_ `
indexPropertyII 
.II 
stringValueII %
=II& '
	EditorGUIII( 1
.II1 2
	TextFieldII2 ;
(II; <
rectII< @
,II@ A
indexPropertyIIB O
.IIO P
stringValueIIP [
)II[ \
;II\ ]
}JJ 	
voidLL ,
 OnExcludeAssemblyListDrawElementLL -
(LL- .
RectLL. 2
rectLL3 7
,LL7 8
intLL9 <
indexLL= B
,LLB C
boolLLD H
isActiveLLI Q
,LLQ R
boolLLS W
	isFocusedLLX a
)LLa b
{MM 	
SerializedPropertyNN 
indexPropertyNN ,
=NN- .
_excludeAssembliesNN/ A
.NNA B"
GetArrayElementAtIndexNNB X
(NNX Y
indexNNY ^
)NN^ _
;NN_ `
	EditorGUIOO 
.OO 

LabelFieldOO  
(OO  !
rectOO! %
,OO% &
indexPropertyOO' 4
.OO4 5
stringValueOO5 @
,OO@ A
EditorStylesOOB N
.OON O
textAreaOOO W
)OOW X
;OOX Y
}PP 	
voidRR ,
 OnIncludeAssemblyListDrawElementRR -
(RR- .
RectRR. 2
rectRR3 7
,RR7 8
intRR9 <
indexRR= B
,RRB C
boolRRD H
isActiveRRI Q
,RRQ R
boolRRS W
	isFocusedRRX a
)RRa b
{SS 	
SerializedPropertyTT 
indexPropertyTT ,
=TT- .
_includeAssembliesTT/ A
.TTA B"
GetArrayElementAtIndexTTB X
(TTX Y
indexTTY ^
)TT^ _
;TT_ `
	EditorGUIUU 
.UU 

LabelFieldUU  
(UU  !
rectUU! %
,UU% &
indexPropertyUU' 4
.UU4 5
stringValueUU5 @
,UU@ A
EditorStylesUUB N
.UUN O
textAreaUUO W
)UUW X
;UUX Y
}VV 	
voidXX )
OnNamespacePatternsDrawHeaderXX *
(XX* +
RectXX+ /
rectXX0 4
)XX4 5
{YY 	
GUIZZ 
.ZZ 
LabelZZ 
(ZZ 
rectZZ 
,ZZ .
"_namespacePatternListHeaderContentZZ >
)ZZ> ?
;ZZ? @
}[[ 	
void]] -
!OnExcludeWeavedAssemblyDrawHeader]] .
(]]. /
Rect]]/ 3
rect]]4 8
)]]8 9
{^^ 	
GUI__ 
.__ 
Label__ 
(__ 
rect__ 
,__ /
#_excludeAssembliesListHeaderContent__ ?
)__? @
;__@ A
}`` 	
voidbb -
!OnIncludeWeavedAssemblyDrawHeaderbb .
(bb. /
Rectbb/ 3
rectbb4 8
)bb8 9
{cc 	
GUIdd 
.dd 
Labeldd 
(dd 
rectdd 
,dd /
#_includeAssembliesListHeaderContentdd ?
)dd? @
;dd@ A
}ee 	
publicgg 
overridegg 
voidgg 
OnInspectorGUIgg +
(gg+ ,
)gg, -
{hh 	
	EditorGUIii 
.ii 
BeginChangeCheckii &
(ii& '
)ii' (
;ii( )
{jj 
	GUILayoutkk 
.kk 
Labelkk 
(kk  
$strkk  *
,kk* +
EditorStyleskk, 8
.kk8 9
	boldLabelkk9 B
)kkB C
;kkC D
EditorGUILayoutmm 
.mm  
PropertyFieldmm  -
(mm- .
_isEnabledInBuildsmm. @
,mm@ A
truemmB F
)mmF G
;mmG H
varoo %
oldIsEnabledInEditorValueoo -
=oo. /
_isEnabledInEditoroo0 B
.ooB C
	boolValueooC L
;ooL M
EditorGUILayoutpp 
.pp  
PropertyFieldpp  -
(pp- .
_isEnabledInEditorpp. @
,pp@ A
trueppB F
)ppF G
;ppG H
ifrr 
(rr %
oldIsEnabledInEditorValuerr -
!=rr. 0
_isEnabledInEditorrr1 C
.rrC D
	boolValuerrD M
)rrM N
{ss (
ReflectionBakingInternalUtiltt 0
.tt0 1$
TryForceUnityFullCompilett1 I
(ttI J
)ttJ K
;ttK L
}uu 
ifxx 
(xx 
_isEnabledInEditorxx &
.xx& '
	boolValuexx' 0
)xx0 1
{yy 
EditorGUILayoutzz #
.zz# $
HelpBoxzz$ +
(zz+ ,
$str{{ y
,{{y z
MessageType	{{{ Ü
.
{{Ü á
Error
{{á å
)
{{å ç
;
{{ç é
}|| 
EditorGUILayout~~ 
.~~  
PropertyField~~  -
(~~- .#
_allGeneratedAssemblies~~. E
,~~E F
true~~G K
)~~K L
;~~L M
if
ÄÄ 
(
ÄÄ %
_allGeneratedAssemblies
ÄÄ +
.
ÄÄ+ ,
	boolValue
ÄÄ, 5
)
ÄÄ5 6
{
ÅÅ $
_excludeAssembliesList
ÇÇ *
.
ÇÇ* +
DoLayoutList
ÇÇ+ 7
(
ÇÇ7 8
)
ÇÇ8 9
;
ÇÇ9 :
GUI
ÑÑ 
.
ÑÑ 
enabled
ÑÑ 
=
ÑÑ  !
false
ÑÑ" '
;
ÑÑ' (
try
ÜÜ 
{
áá $
_includeAssembliesList
àà .
.
àà. /
DoLayoutList
àà/ ;
(
àà; <
)
àà< =
;
àà= >
}
ââ 
finally
ää 
{
ãã 
GUI
åå 
.
åå 
enabled
åå #
=
åå$ %
true
åå& *
;
åå* +
}
çç 
}
éé 
else
èè 
{
êê 
GUI
ëë 
.
ëë 
enabled
ëë 
=
ëë  !
false
ëë" '
;
ëë' (
try
ìì 
{
îî $
_excludeAssembliesList
ïï .
.
ïï. /
DoLayoutList
ïï/ ;
(
ïï; <
)
ïï< =
;
ïï= >
}
ññ 
finally
óó 
{
òò 
GUI
ôô 
.
ôô 
enabled
ôô #
=
ôô$ %
true
ôô& *
;
ôô* +
}
öö $
_includeAssembliesList
úú *
.
úú* +
DoLayoutList
úú+ 7
(
úú7 8
)
úú8 9
;
úú9 :
}
ùù $
_namespacePatternsList
üü &
.
üü& '
DoLayoutList
üü' 3
(
üü3 4
)
üü4 5
;
üü5 6
}
†† 
if
¢¢ 
(
¢¢ 
	EditorGUI
¢¢ 
.
¢¢ 
EndChangeCheck
¢¢ (
(
¢¢( )
)
¢¢) *
)
¢¢* +
{
££ $
_hasModifiedProperties
§§ &
=
§§' (
true
§§) -
;
§§- .
}
•• 
if
ßß 
(
ßß $
_hasModifiedProperties
ßß &
)
ßß& '
{
®® $
_hasModifiedProperties
©© &
=
©©' (
false
©©) .
;
©©. /%
ApplyModifiedProperties
™™ '
(
™™' (
)
™™( )
;
™™) *
}
´´ 
}
¨¨ 	
void
ÆÆ %
ApplyModifiedProperties
ÆÆ $
(
ÆÆ$ %
)
ÆÆ% &
{
ØØ 	
serializedObject
∞∞ 
.
∞∞ %
ApplyModifiedProperties
∞∞ 4
(
∞∞4 5
)
∞∞5 6
;
∞∞6 7
serializedObject
±± 
.
±± 
Update
±± #
(
±±# $
)
±±$ %
;
±±% &
}
≤≤ 	
void
¥¥ 1
#OnExcludeWeavedAssemblyElementAdded
¥¥ 0
(
¥¥0 1
ReorderableList
¥¥1 @
list
¥¥A E
)
¥¥E F
{
µµ 	$
OnAssemblyElementAdded
∂∂ "
(
∂∂" # 
_excludeAssemblies
∂∂# 5
,
∂∂5 6
list
∂∂7 ;
)
∂∂; <
;
∂∂< =
}
∑∑ 	
void
ππ 1
#OnIncludeWeavedAssemblyElementAdded
ππ 0
(
ππ0 1
ReorderableList
ππ1 @
list
ππA E
)
ππE F
{
∫∫ 	$
OnAssemblyElementAdded
ªª "
(
ªª" # 
_includeAssemblies
ªª# 5
,
ªª5 6
list
ªª7 ;
)
ªª; <
;
ªª< =
}
ºº 	
void
ææ $
OnAssemblyElementAdded
ææ #
(
ææ# $ 
SerializedProperty
ææ$ 6
listProperty
ææ7 C
,
ææC D
ReorderableList
ææE T
list
ææU Y
)
ææY Z
{
øø 	
GenericMenu
¿¿ 
menu
¿¿ 
=
¿¿ 
new
¿¿ "
GenericMenu
¿¿# .
(
¿¿. /
)
¿¿/ 0
;
¿¿0 1
var
¬¬ 
paths
¬¬ 
=
¬¬ "
AssemblyPathRegistry
¬¬ ,
.
¬¬, -2
$GetAllGeneratedAssemblyRelativePaths
¬¬- Q
(
¬¬Q R
)
¬¬R S
;
¬¬S T
for
ƒƒ 
(
ƒƒ 
int
ƒƒ 
i
ƒƒ 
=
ƒƒ 
$num
ƒƒ 
;
ƒƒ 
i
ƒƒ 
<
ƒƒ 
paths
ƒƒ  %
.
ƒƒ% &
Count
ƒƒ& +
;
ƒƒ+ ,
i
ƒƒ- .
++
ƒƒ. 0
)
ƒƒ0 1
{
≈≈ 
var
∆∆ 
path
∆∆ 
=
∆∆ 
paths
∆∆  
[
∆∆  !
i
∆∆! "
]
∆∆" #
;
∆∆# $
bool
»» 

foundMatch
»» 
=
»»  !
false
»»" '
;
»»' (
for
   
(
   
int
   
k
   
=
   
$num
   
;
   
k
    !
<
  " #
listProperty
  $ 0
.
  0 1
	arraySize
  1 :
;
  : ;
k
  < =
++
  = ?
)
  ? @
{
ÀÀ  
SerializedProperty
ÃÃ &
current
ÃÃ' .
=
ÃÃ/ 0
listProperty
ÃÃ1 =
.
ÃÃ= >$
GetArrayElementAtIndex
ÃÃ> T
(
ÃÃT U
k
ÃÃU V
)
ÃÃV W
;
ÃÃW X
if
ŒŒ 
(
ŒŒ 
path
ŒŒ 
==
ŒŒ 
current
ŒŒ  '
.
ŒŒ' (
stringValue
ŒŒ( 3
)
ŒŒ3 4
{
œœ 

foundMatch
–– "
=
––# $
true
––% )
;
––) *
break
—— 
;
—— 
}
““ 
}
”” 
if
’’ 
(
’’ 
!
’’ 

foundMatch
’’ 
)
’’  
{
÷÷ 

GUIContent
◊◊ 
content
◊◊ &
=
◊◊' (
new
◊◊) ,

GUIContent
◊◊- 7
(
◊◊7 8
path
◊◊8 <
)
◊◊< =
;
◊◊= >
menu
ÿÿ 
.
ÿÿ 
AddItem
ÿÿ  
(
ÿÿ  !
content
ÿÿ! (
,
ÿÿ( )
false
ÿÿ* /
,
ÿÿ/ 0
p
ÿÿ1 2
=>
ÿÿ3 5#
OnWeavedAssemblyAdded
ÿÿ6 K
(
ÿÿK L
listProperty
ÿÿL X
,
ÿÿX Y
p
ÿÿZ [
)
ÿÿ[ \
,
ÿÿ\ ]
path
ÿÿ^ b
)
ÿÿb c
;
ÿÿc d
}
ŸŸ 
}
⁄⁄ 
if
‹‹ 
(
‹‹ 
menu
‹‹ 
.
‹‹ 
GetItemCount
‹‹ !
(
‹‹! "
)
‹‹" #
==
‹‹$ &
$num
‹‹' (
)
‹‹( )
{
›› 
menu
ﬁﬁ 
.
ﬁﬁ 
AddDisabledItem
ﬁﬁ $
(
ﬁﬁ$ %
new
ﬁﬁ% (

GUIContent
ﬁﬁ) 3
(
ﬁﬁ3 4
$str
ﬁﬁ4 L
)
ﬁﬁL M
)
ﬁﬁM N
;
ﬁﬁN O
}
ﬂﬂ 
menu
·· 
.
·· 
ShowAsContext
·· 
(
·· 
)
··  
;
··  !
}
‚‚ 	
void
‰‰ #
OnWeavedAssemblyAdded
‰‰ "
(
‰‰" # 
SerializedProperty
‰‰# 5
listProperty
‰‰6 B
,
‰‰B C
object
‰‰D J
path
‰‰K O
)
‰‰O P
{
ÂÂ 	
listProperty
ÊÊ 
.
ÊÊ 
	arraySize
ÊÊ "
++
ÊÊ" $
;
ÊÊ$ % 
SerializedProperty
ÁÁ 
weaved
ÁÁ %
=
ÁÁ& '
listProperty
ÁÁ( 4
.
ÁÁ4 5$
GetArrayElementAtIndex
ÁÁ5 K
(
ÁÁK L
listProperty
ÁÁL X
.
ÁÁX Y
	arraySize
ÁÁY b
-
ÁÁc d
$num
ÁÁe f
)
ÁÁf g
;
ÁÁg h
weaved
ËË 
.
ËË 
stringValue
ËË 
=
ËË  
(
ËË! "
(
ËË" #
string
ËË# )
)
ËË) *
path
ËË* .
)
ËË. /
.
ËË/ 0
Replace
ËË0 7
(
ËË7 8
$str
ËË8 <
,
ËË< =
$str
ËË> A
)
ËËA B
;
ËËB C%
ApplyModifiedProperties
ÈÈ #
(
ÈÈ# $
)
ÈÈ$ %
;
ÈÈ% &
}
ÍÍ 	
}
ÎÎ 
}ÏÏ êà
rC:\Users\–ö–ª–∏–º–Ω—é–∫\tring\App\Assets\Plugins\Zenject\OptionalExtras\ReflectionBaking\Common\CecilExtensions.cs
	namespace

 	
Zenject


 
.

 
ReflectionBaking

 "
{ 
public 

static 
class 
CecilExtensions '
{ 
public 
static 
Type 
TryGetActualType +
(+ ,
this, 0
TypeReference1 >
typeRef? F
,F G
AssemblyH P
assemblyQ Y
)Y Z
{ 	
var 
reflectionName 
=  
GetReflectionName! 2
(2 3
typeRef3 :
): ;
;; <
return 
assembly 
. 
GetType #
(# $
reflectionName$ 2
)2 3
;3 4
} 	
static 
string 
GetReflectionName '
(' (
TypeReference( 5
type6 :
): ;
{ 	
if 
( 
type 
. 
IsGenericInstance &
)& '
{ 
var 
genericInstance #
=$ %
(& '
GenericInstanceType' :
): ;
type; ?
;? @
return 
string 
. 
Format $
($ %
$str "
," #
genericInstance$ 3
.3 4
	Namespace4 =
,= >
type? C
.C D
NameD H
,H I
String 
. 
Join 
(  
$str  #
,# $
genericInstance% 4
.4 5
GenericArguments5 E
.E F
SelectF L
(L M
pM N
=>O Q
GetReflectionNameR c
(c d
pd e
)e f
)f g
.g h
ToArrayh o
(o p
)p q
)q r
)r s
;s t
} 
return 
type 
. 
FullName  
;  !
}   	
public"" 
static"" 
List"" 
<"" 
TypeDefinition"" )
>"") *
LookupAllTypes""+ 9
(""9 :
this"": >
ModuleDefinition""? O
module""P V
)""V W
{## 	
var$$ 
allTypes$$ 
=$$ 
new$$ 
List$$ #
<$$# $
TypeDefinition$$$ 2
>$$2 3
($$3 4
)$$4 5
;$$5 6
foreach&& 
(&& 
var&& 
type&& 
in&&  
module&&! '
.&&' (
Types&&( -
)&&- .
{'' "
LookupAllTypesInternal(( &
(((& '
type((' +
,((+ ,
allTypes((- 5
)((5 6
;((6 7
})) 
return++ 
allTypes++ 
;++ 
},, 	
static.. 
void.. "
LookupAllTypesInternal.. *
(..* +
TypeDefinition..+ 9
type..: >
,..> ?
List..@ D
<..D E
TypeDefinition..E S
>..S T
buffer..U [
)..[ \
{// 	
buffer00 
.00 
Add00 
(00 
type00 
)00 
;00 
foreach22 
(22 
var22 

nestedType22 #
in22$ &
type22' +
.22+ ,
NestedTypes22, 7
)227 8
{33 "
LookupAllTypesInternal44 &
(44& '

nestedType44' 1
,441 2
buffer443 9
)449 :
;44: ;
}55 
}66 	
public88 
static88 
TypeReference88 #

ImportType88$ .
<88. /
T88/ 0
>880 1
(881 2
this882 6
ModuleDefinition887 G
module88H N
)88N O
{99 	
return:: 
module:: 
.:: 

ImportType:: $
(::$ %
typeof::% +
(::+ ,
T::, -
)::- .
)::. /
;::/ 0
};; 	
public== 
static== 
TypeReference== #

ImportType==$ .
(==. /
this==/ 3
ModuleDefinition==4 D
module==E K
,==K L
Type==M Q
type==R V
)==V W
{>> 	
return?? 
module?? 
.?? 
Import??  
(??  !
type??! %
)??% &
;??& '
}@@ 	
publicBB 
staticBB 
MethodReferenceBB %
ImportMethodBB& 2
<BB2 3
TBB3 4
>BB4 5
(BB5 6
thisBB6 :
ModuleDefinitionBB; K
moduleBBL R
,BBR S
stringBBT Z

methodNameBB[ e
)BBe f
{CC 	
returnDD 
moduleDD 
.DD 
ImportMethodDD &
(DD& '
typeofDD' -
(DD- .
TDD. /
)DD/ 0
,DD0 1

methodNameDD2 <
)DD< =
;DD= >
}EE 	
publicGG 
staticGG 
MethodReferenceGG %
ImportMethodGG& 2
(GG2 3
thisHH 
ModuleDefinitionHH !
moduleHH" (
,HH( )
TypeHH* .
typeHH/ 3
,HH3 4
stringHH5 ;

methodNameHH< F
)HHF G
{II 	
returnJJ 
moduleJJ 
.JJ 
ImportJJ  
(JJ  !
moduleKK 
.KK 

ImportTypeKK !
(KK! "
typeKK" &
)KK& '
.KK' (
ResolveKK( /
(KK/ 0
)KK0 1
.KK1 2
	GetMethodKK2 ;
(KK; <

methodNameKK< F
)KKF G
)KKG H
;KKH I
}LL 	
publicNN 
staticNN 
MethodReferenceNN %
ImportMethodNN& 2
<NN2 3
TNN3 4
>NN4 5
(NN5 6
thisOO 
ModuleDefinitionOO !
moduleOO" (
,OO( )
stringOO* 0

methodNameOO1 ;
,OO; <
intOO= @
numArgsOOA H
)OOH I
{PP 	
returnQQ 
moduleQQ 
.QQ 
ImportMethodQQ &
(QQ& '
typeofQQ' -
(QQ- .
TQQ. /
)QQ/ 0
,QQ0 1

methodNameQQ2 <
,QQ< =
numArgsQQ> E
)QQE F
;QQF G
}RR 	
publicTT 
staticTT 
MethodReferenceTT %
ImportMethodTT& 2
(TT2 3
thisUU 
ModuleDefinitionUU !
moduleUU" (
,UU( )
TypeUU* .
typeUU/ 3
,UU3 4
stringUU5 ;

methodNameUU< F
,UUF G
intUUH K
numArgsUUL S
)UUS T
{VV 	
returnWW 
moduleWW 
.WW 
ImportWW  
(WW  !
moduleXX 
.XX 

ImportTypeXX !
(XX! "
typeXX" &
)XX& '
.XX' (
ResolveXX( /
(XX/ 0
)XX0 1
.XX1 2
	GetMethodXX2 ;
(XX; <

methodNameXX< F
,XXF G
numArgsXXH O
)XXO P
)XXP Q
;XXQ R
}YY 	
public[[ 
static[[ 
MethodDefinition[[ &
	GetMethod[[' 0
([[0 1
this[[1 5
TypeDefinition[[6 D
instance[[E M
,[[M N
string[[O U
name[[V Z
)[[Z [
{\\ 	
for]] 
(]] 
int]] 
i]] 
=]] 
$num]] 
;]] 
i]] 
<]] 
instance]]  (
.]]( )
Methods]]) 0
.]]0 1
Count]]1 6
;]]6 7
i]]8 9
++]]9 ;
)]]; <
{^^ 
MethodDefinition__  
	methodDef__! *
=__+ ,
instance__- 5
.__5 6
Methods__6 =
[__= >
i__> ?
]__? @
;__@ A
ifaa 
(aa 
stringaa 
.aa 
CompareOrdinalaa )
(aa) *
	methodDefaa* 3
.aa3 4
Nameaa4 8
,aa8 9
nameaa: >
)aa> ?
==aa@ B
$numaaC D
)aaD E
{bb 
returncc 
	methodDefcc $
;cc$ %
}dd 
}ee 
returnff 
nullff 
;ff 
}gg 	
publicii 
staticii 
MethodDefinitionii &
	GetMethodii' 0
(ii0 1
thisii1 5
TypeDefinitionii6 D
instanceiiE M
,iiM N
stringiiO U
nameiiV Z
,iiZ [
paramsii\ b
Typeiic g
[iig h
]iih i
parameterTypesiij x
)iix y
{jj 	
forkk 
(kk 
intkk 
ikk 
=kk 
$numkk 
;kk 
ikk 
<kk 
instancekk  (
.kk( )
Methodskk) 0
.kk0 1
Countkk1 6
;kk6 7
ikk8 9
++kk9 ;
)kk; <
{ll 
MethodDefinitionmm  
methodDefinitionmm! 1
=mm2 3
instancemm4 <
.mm< =
Methodsmm= D
[mmD E
immE F
]mmF G
;mmG H
ifoo 
(oo 
!oo 
stringoo 
.oo 
Equalsoo "
(oo" #
methodDefinitionoo# 3
.oo3 4
Nameoo4 8
,oo8 9
nameoo: >
,oo> ?
StringComparisonoo@ P
.ooP Q
OrdinalooQ X
)ooX Y
||ooZ \
parameterTypespp "
.pp" #
Lengthpp# )
!=pp* ,
methodDefinitionpp- =
.pp= >

Parameterspp> H
.ppH I
CountppI N
)ppN O
{qq 
continuerr 
;rr 
}ss 
MethodDefinitionuu  
resultuu! '
=uu( )
methodDefinitionuu* :
;uu: ;
forvv 
(vv 
intvv 
xvv 
=vv 
methodDefinitionvv -
.vv- .

Parametersvv. 8
.vv8 9
Countvv9 >
-vv? @
$numvvA B
;vvB C
xvvD E
>=vvF H
$numvvI J
;vvJ K
xvvL M
--vvM O
)vvO P
{ww 
ParameterDefinitionxx '
	parameterxx( 1
=xx2 3
methodDefinitionxx4 D
.xxD E

ParametersxxE O
[xxO P
xxxP Q
]xxQ R
;xxR S
ifyy 
(yy 
!yy 
stringyy 
.yy  
Equalsyy  &
(yy& '
	parameteryy' 0
.yy0 1
ParameterTypeyy1 >
.yy> ?
Nameyy? C
,yyC D
parameterTypesyyE S
[yyS T
xyyT U
]yyU V
.yyV W
NameyyW [
,yy[ \
StringComparisonyy] m
.yym n
Ordinalyyn u
)yyu v
)yyv w
{zz 
break{{ 
;{{ 
}|| 
if~~ 
(~~ 
x~~ 
==~~ 
$num~~ 
)~~ 
{ 
return
ÄÄ 
result
ÄÄ %
;
ÄÄ% &
}
ÅÅ 
}
ÇÇ 
}
ÉÉ 
return
ÑÑ 
null
ÑÑ 
;
ÑÑ 
}
ÖÖ 	
public
áá 
static
áá 
MethodDefinition
áá &
	GetMethod
áá' 0
(
áá0 1
this
áá1 5
TypeDefinition
áá6 D
instance
ááE M
,
ááM N
string
ááO U
name
ááV Z
,
ááZ [
params
áá\ b
TypeReference
áác p
[
ááp q
]
ááq r
parameterTypesáás Å
)ááÅ Ç
{
àà 	
if
ââ 
(
ââ 
instance
ââ 
.
ââ 
Methods
ââ  
!=
ââ! #
null
ââ$ (
)
ââ( )
{
ää 
for
ãã 
(
ãã 
int
ãã 
i
ãã 
=
ãã 
$num
ãã 
;
ãã 
i
ãã  !
<
ãã" #
instance
ãã$ ,
.
ãã, -
Methods
ãã- 4
.
ãã4 5
Count
ãã5 :
;
ãã: ;
i
ãã< =
++
ãã= ?
)
ãã? @
{
åå 
MethodDefinition
çç $
methodDefinition
çç% 5
=
çç6 7
instance
çç8 @
.
çç@ A
Methods
ççA H
[
ççH I
i
ççI J
]
ççJ K
;
ççK L
if
éé 
(
éé 
string
éé 
.
éé 
Equals
éé %
(
éé% &
methodDefinition
éé& 6
.
éé6 7
Name
éé7 ;
,
éé; <
name
éé= A
,
ééA B
StringComparison
ééC S
.
ééS T
Ordinal
ééT [
)
éé[ \
&&
èè 
parameterTypes
èè )
.
èè) *
Length
èè* 0
==
èè1 3
methodDefinition
èè4 D
.
èèD E

Parameters
èèE O
.
èèO P
Count
èèP U
)
èèU V
{
êê 
MethodDefinition
ëë (
result
ëë) /
=
ëë0 1
methodDefinition
ëë2 B
;
ëëB C
for
íí 
(
íí 
int
íí  
x
íí! "
=
íí# $
methodDefinition
íí% 5
.
íí5 6

Parameters
íí6 @
.
íí@ A
Count
ííA F
-
ííG H
$num
ííI J
;
ííJ K
x
ííL M
>=
ííN P
$num
ííQ R
;
ííR S
x
ííT U
--
ííU W
)
ííW X
{
ìì !
ParameterDefinition
îî /
	parameter
îî0 9
=
îî: ;
methodDefinition
îî< L
.
îîL M

Parameters
îîM W
[
îîW X
x
îîX Y
]
îîY Z
;
îîZ [
if
ïï 
(
ïï  
!
ïï  !
string
ïï! '
.
ïï' (
Equals
ïï( .
(
ïï. /
	parameter
ïï/ 8
.
ïï8 9
ParameterType
ïï9 F
.
ïïF G
Name
ïïG K
,
ïïK L
parameterTypes
ïïM [
[
ïï[ \
x
ïï\ ]
]
ïï] ^
.
ïï^ _
Name
ïï_ c
,
ïïc d
StringComparison
ïïe u
.
ïïu v
Ordinal
ïïv }
)
ïï} ~
)
ïï~ 
{
ññ 
break
óó  %
;
óó% &
}
òò 
if
öö 
(
öö  
x
öö  !
==
öö" $
$num
öö% &
)
öö& '
{
õõ 
return
úú  &
result
úú' -
;
úú- .
}
ùù 
}
ûû 
}
üü 
}
†† 
}
°° 
return
¢¢ 
null
¢¢ 
;
¢¢ 
}
££ 	
public
•• 
static
•• 
MethodDefinition
•• &
	GetMethod
••' 0
(
••0 1
this
••1 5
TypeDefinition
••6 D
instance
••E M
,
••M N
string
••O U
name
••V Z
,
••Z [
int
••\ _
argCount
••` h
)
••h i
{
¶¶ 	
for
ßß 
(
ßß 
int
ßß 
i
ßß 
=
ßß 
$num
ßß 
;
ßß 
i
ßß 
<
ßß 
instance
ßß  (
.
ßß( )
Methods
ßß) 0
.
ßß0 1
Count
ßß1 6
;
ßß6 7
i
ßß8 9
++
ßß9 ;
)
ßß; <
{
®® 
MethodDefinition
©©  
	methodDef
©©! *
=
©©+ ,
instance
©©- 5
.
©©5 6
Methods
©©6 =
[
©©= >
i
©©> ?
]
©©? @
;
©©@ A
if
´´ 
(
´´ 
string
´´ 
.
´´ 
CompareOrdinal
´´ )
(
´´) *
	methodDef
´´* 3
.
´´3 4
Name
´´4 8
,
´´8 9
name
´´: >
)
´´> ?
==
´´@ B
$num
´´C D
&&
´´E G
	methodDef
´´H Q
.
´´Q R

Parameters
´´R \
.
´´\ ]
Count
´´] b
==
´´c e
argCount
´´f n
)
´´n o
{
¨¨ 
return
≠≠ 
	methodDef
≠≠ $
;
≠≠$ %
}
ÆÆ 
}
ØØ 
return
∞∞ 
null
∞∞ 
;
∞∞ 
}
±± 	
public
≥≥ 
static
≥≥  
PropertyDefinition
≥≥ (#
GetPropertyDefinition
≥≥) >
(
≥≥> ?
this
≥≥? C
TypeDefinition
≥≥D R
instance
≥≥S [
,
≥≥[ \
string
≥≥] c
name
≥≥d h
)
≥≥h i
{
¥¥ 	
for
µµ 
(
µµ 
int
µµ 
i
µµ 
=
µµ 
$num
µµ 
;
µµ 
i
µµ 
<
µµ 
instance
µµ  (
.
µµ( )

Properties
µµ) 3
.
µµ3 4
Count
µµ4 9
;
µµ9 :
i
µµ; <
++
µµ< >
)
µµ> ?
{
∂∂  
PropertyDefinition
∑∑ "
preopertyDef
∑∑# /
=
∑∑0 1
instance
∑∑2 :
.
∑∑: ;

Properties
∑∑; E
[
∑∑E F
i
∑∑F G
]
∑∑G H
;
∑∑H I
if
∫∫ 
(
∫∫ 
string
∫∫ 
.
∫∫ 
CompareOrdinal
∫∫ )
(
∫∫) *
preopertyDef
∫∫* 6
.
∫∫6 7
Name
∫∫7 ;
,
∫∫; <
name
∫∫= A
)
∫∫A B
==
∫∫C E
$num
∫∫F G
&&
∫∫H J
preopertyDef
∫∫K W
.
∫∫W X

Parameters
∫∫X b
.
∫∫b c
Count
∫∫c h
==
∫∫i k
$num
∫∫l m
)
∫∫m n
{
ªª 
return
ºº 
preopertyDef
ºº '
;
ºº' (
}
ΩΩ 
}
ææ 
return
øø 
null
øø 
;
øø 
}
¿¿ 	
public
¬¬ 
static
¬¬ 
bool
¬¬  
HasCustomAttribute
¬¬ -
<
¬¬- .
T
¬¬. /
>
¬¬/ 0
(
¬¬0 1
this
¬¬1 5&
ICustomAttributeProvider
¬¬6 N
instance
¬¬O W
)
¬¬W X
{
√√ 	
if
ƒƒ 
(
ƒƒ 
!
ƒƒ 
instance
ƒƒ 
.
ƒƒ !
HasCustomAttributes
ƒƒ -
)
ƒƒ- .
{
≈≈ 
return
∆∆ 
false
∆∆ 
;
∆∆ 
}
«« 

Collection
…… 
<
…… 
CustomAttribute
…… &
>
……& '

attributes
……( 2
=
……3 4
instance
……5 =
.
……= >
CustomAttributes
……> N
;
……N O
for
ÀÀ 
(
ÀÀ 
int
ÀÀ 
i
ÀÀ 
=
ÀÀ 
$num
ÀÀ 
;
ÀÀ 
i
ÀÀ 
<
ÀÀ 

attributes
ÀÀ  *
.
ÀÀ* +
Count
ÀÀ+ 0
;
ÀÀ0 1
i
ÀÀ2 3
++
ÀÀ3 5
)
ÀÀ5 6
{
ÃÃ 
if
ÕÕ 
(
ÕÕ 

attributes
ÕÕ 
[
ÕÕ 
i
ÕÕ  
]
ÕÕ  !
.
ÕÕ! "
AttributeType
ÕÕ" /
.
ÕÕ/ 0
FullName
ÕÕ0 8
.
ÕÕ8 9
Equals
ÕÕ9 ?
(
ÕÕ? @
typeof
ÕÕ@ F
(
ÕÕF G
T
ÕÕG H
)
ÕÕH I
.
ÕÕI J
FullName
ÕÕJ R
,
ÕÕR S
StringComparison
ÕÕT d
.
ÕÕd e
Ordinal
ÕÕe l
)
ÕÕl m
)
ÕÕm n
{
ŒŒ 
return
œœ 
true
œœ 
;
œœ  
}
–– 
}
—— 
return
”” 
false
”” 
;
”” 
}
‘‘ 	
public
÷÷ 
static
÷÷ 
MethodReference
÷÷ %!
ChangeDeclaringType
÷÷& 9
(
÷÷9 :
this
◊◊ 
MethodReference
◊◊  
	methodDef
◊◊! *
,
◊◊* +
TypeReference
◊◊, 9
typeRef
◊◊: A
)
◊◊A B
{
ÿÿ 	
var
ŸŸ 
newMethodRef
ŸŸ 
=
ŸŸ 
new
ŸŸ "
MethodReference
ŸŸ# 2
(
ŸŸ2 3
	methodDef
⁄⁄ 
.
⁄⁄ 
Name
⁄⁄ 
,
⁄⁄ 
	methodDef
⁄⁄  )
.
⁄⁄) *

ReturnType
⁄⁄* 4
,
⁄⁄4 5
typeRef
⁄⁄6 =
)
⁄⁄= >
;
⁄⁄> ?
newMethodRef
‹‹ 
.
‹‹ 
HasThis
‹‹  
=
‹‹! "
	methodDef
‹‹# ,
.
‹‹, -
HasThis
‹‹- 4
;
‹‹4 5
foreach
ﬁﬁ 
(
ﬁﬁ 
var
ﬁﬁ 
arg
ﬁﬁ 
in
ﬁﬁ 
	methodDef
ﬁﬁ  )
.
ﬁﬁ) *

Parameters
ﬁﬁ* 4
)
ﬁﬁ4 5
{
ﬂﬂ 
var
‡‡ 
paramDef
‡‡ 
=
‡‡ 
new
‡‡ "!
ParameterDefinition
‡‡# 6
(
‡‡6 7
arg
‡‡7 :
.
‡‡: ;
ParameterType
‡‡; H
)
‡‡H I
;
‡‡I J
newMethodRef
‚‚ 
.
‚‚ 

Parameters
‚‚ '
.
‚‚' (
Add
‚‚( +
(
‚‚+ ,
paramDef
‚‚, 4
)
‚‚4 5
;
‚‚5 6
}
„„ 
return
ÂÂ 
newMethodRef
ÂÂ 
;
ÂÂ  
}
ÊÊ 	
public
ËË 
static
ËË 
FieldReference
ËË $!
ChangeDeclaringType
ËË% 8
(
ËË8 9
this
ÈÈ 
FieldReference
ÈÈ 
fieldDef
ÈÈ  (
,
ÈÈ( )
TypeReference
ÈÈ* 7
typeRef
ÈÈ8 ?
)
ÈÈ? @
{
ÍÍ 	
return
ÎÎ 
new
ÎÎ 
FieldReference
ÎÎ %
(
ÎÎ% &
fieldDef
ÏÏ 
.
ÏÏ 
Name
ÏÏ 
,
ÏÏ 
fieldDef
ÏÏ '
.
ÏÏ' (
	FieldType
ÏÏ( 1
,
ÏÏ1 2
typeRef
ÏÏ3 :
)
ÏÏ: ;
;
ÏÏ; <
}
ÌÌ 	
public
ÔÔ 
static
ÔÔ 
CustomAttribute
ÔÔ % 
GetCustomAttribute
ÔÔ& 8
<
ÔÔ8 9
T
ÔÔ9 :
>
ÔÔ: ;
(
ÔÔ; <
this
ÔÔ< @&
ICustomAttributeProvider
ÔÔA Y
instance
ÔÔZ b
)
ÔÔb c
{
 	
if
ÒÒ 
(
ÒÒ 
!
ÒÒ 
instance
ÒÒ 
.
ÒÒ !
HasCustomAttributes
ÒÒ -
)
ÒÒ- .
{
ÚÚ 
return
ÛÛ 
null
ÛÛ 
;
ÛÛ 
}
ÙÙ 

Collection
ˆˆ 
<
ˆˆ 
CustomAttribute
ˆˆ &
>
ˆˆ& '

attributes
ˆˆ( 2
=
ˆˆ3 4
instance
ˆˆ5 =
.
ˆˆ= >
CustomAttributes
ˆˆ> N
;
ˆˆN O
for
¯¯ 
(
¯¯ 
int
¯¯ 
i
¯¯ 
=
¯¯ 
$num
¯¯ 
;
¯¯ 
i
¯¯ 
<
¯¯ 

attributes
¯¯  *
.
¯¯* +
Count
¯¯+ 0
;
¯¯0 1
i
¯¯2 3
++
¯¯3 5
)
¯¯5 6
{
˘˘ 
if
˙˙ 
(
˙˙ 

attributes
˙˙ 
[
˙˙ 
i
˙˙  
]
˙˙  !
.
˙˙! "
AttributeType
˙˙" /
.
˙˙/ 0
FullName
˙˙0 8
.
˙˙8 9
Equals
˙˙9 ?
(
˙˙? @
typeof
˙˙@ F
(
˙˙F G
T
˙˙G H
)
˙˙H I
.
˙˙I J
FullName
˙˙J R
,
˙˙R S
StringComparison
˙˙T d
.
˙˙d e
Ordinal
˙˙e l
)
˙˙l m
)
˙˙m n
{
˚˚ 
return
¸¸ 

attributes
¸¸ %
[
¸¸% &
i
¸¸& '
]
¸¸' (
;
¸¸( )
}
˝˝ 
}
˛˛ 
return
ˇˇ 
null
ˇˇ 
;
ˇˇ 
}
ÄÄ 	
public
ÇÇ 
static
ÇÇ 
IEnumerable
ÇÇ !
<
ÇÇ! "
TypeReference
ÇÇ" /
>
ÇÇ/ 0)
GetSpecificBaseTypesAndSelf
ÇÇ1 L
(
ÇÇL M
this
ÉÉ 
TypeReference
ÉÉ 
specificTypeRef
ÉÉ .
)
ÉÉ. /
{
ÑÑ 	
yield
ÖÖ 
return
ÖÖ 
specificTypeRef
ÖÖ (
;
ÖÖ( )
foreach
áá 
(
áá 
var
áá 
ancestor
áá !
in
áá" $
specificTypeRef
áá% 4
.
áá4 5)
GetSpecificBaseTypesAndSelf
áá5 P
(
ááP Q
)
ááQ R
)
ááR S
{
àà 
yield
ââ 
return
ââ 
ancestor
ââ %
;
ââ% &
}
ää 
}
ãã 	
public
çç 
static
çç 
IEnumerable
çç !
<
çç! "
TypeReference
çç" /
>
çç/ 0"
GetSpecificBaseTypes
çç1 E
(
ççE F
this
éé 
TypeReference
éé 
specificTypeRef
éé .
)
éé. /
{
èè 	
var
êê !
specificBaseTypeRef
êê #
=
êê$ %
specificTypeRef
êê& 5
.
êê5 6$
TryGetSpecificBaseType
êê6 L
(
êêL M
)
êêM N
;
êêN O
if
íí 
(
íí !
specificBaseTypeRef
íí #
!=
íí$ &
null
íí' +
)
íí+ ,
{
ìì 
yield
îî 
return
îî !
specificBaseTypeRef
îî 0
;
îî0 1
foreach
ññ 
(
ññ 
var
ññ 
ancestor
ññ %
in
ññ& ("
GetSpecificBaseTypes
ññ) =
(
ññ= >!
specificBaseTypeRef
ññ> Q
)
ññQ R
)
ññR S
{
óó 
yield
òò 
return
òò  
ancestor
òò! )
;
òò) *
}
ôô 
}
öö 
}
õõ 	
public
ùù 
static
ùù 
IEnumerable
ùù !
<
ùù! "
TypeReference
ùù" /
>
ùù/ 0#
AllNestParentsAndSelf
ùù1 F
(
ùùF G
this
ùùG K
TypeReference
ùùL Y
specificTypeRef
ùùZ i
)
ùùi j
{
ûû 	
yield
üü 
return
üü 
specificTypeRef
üü (
;
üü( )
foreach
°° 
(
°° 
var
°° 
ancestor
°° !
in
°°" $
specificTypeRef
°°% 4
.
°°4 5
AllNestParents
°°5 C
(
°°C D
)
°°D E
)
°°E F
{
¢¢ 
yield
££ 
return
££ 
ancestor
££ %
;
££% &
}
§§ 
}
•• 	
public
ßß 
static
ßß 
IEnumerable
ßß !
<
ßß! "
TypeReference
ßß" /
>
ßß/ 0
AllNestParents
ßß1 ?
(
ßß? @
this
ßß@ D
TypeReference
ßßE R
specificTypeRef
ßßS b
)
ßßb c
{
®® 	
if
©© 
(
©© 
specificTypeRef
©© 
.
©©  
DeclaringType
©©  -
!=
©©. 0
null
©©1 5
)
©©5 6
{
™™ 
yield
´´ 
return
´´ 
specificTypeRef
´´ ,
.
´´, -
DeclaringType
´´- :
;
´´: ;
foreach
≠≠ 
(
≠≠ 
var
≠≠ 
ancestor
≠≠ %
in
≠≠& (
specificTypeRef
≠≠) 8
.
≠≠8 9
DeclaringType
≠≠9 F
.
≠≠F G
AllNestParents
≠≠G U
(
≠≠U V
)
≠≠V W
)
≠≠W X
{
ÆÆ 
yield
ØØ 
return
ØØ  
ancestor
ØØ! )
;
ØØ) *
}
∞∞ 
}
±± 
}
≤≤ 	
public
¥¥ 
static
¥¥ 
TypeReference
¥¥ #

TryResolve
¥¥$ .
(
¥¥. /
this
¥¥/ 3
TypeReference
¥¥4 A
typeRef
¥¥B I
)
¥¥I J
{
µµ 	
try
∂∂ 
{
∑∑ 
return
∏∏ 
typeRef
∏∏ 
.
∏∏ 
Resolve
∏∏ &
(
∏∏& '
)
∏∏' (
;
∏∏( )
}
ππ 
catch
∫∫ 
{
ªª 
return
ºº 
null
ºº 
;
ºº 
}
ΩΩ 
}
ææ 	
public
¿¿ 
static
¿¿ 
TypeReference
¿¿ #$
TryGetSpecificBaseType
¿¿$ :
(
¿¿: ;
this
¿¿; ?
TypeReference
¿¿@ M
specificTypeRef
¿¿N ]
)
¿¿] ^
{
¡¡ 	
var
¬¬ 
typeDef
¬¬ 
=
¬¬ 
specificTypeRef
¬¬ )
.
¬¬) *
Resolve
¬¬* 1
(
¬¬1 2
)
¬¬2 3
;
¬¬3 4
if
ƒƒ 
(
ƒƒ 
typeDef
ƒƒ 
.
ƒƒ 
BaseType
ƒƒ  
==
ƒƒ! #
null
ƒƒ$ (
||
≈≈ 
typeDef
≈≈ 
.
≈≈ 
BaseType
≈≈ #
.
≈≈# $
FullName
≈≈$ ,
==
≈≈- /
$str
≈≈0 ?
)
≈≈? @
{
∆∆ 
return
«« 
null
«« 
;
«« 
}
»» 
var
   !
specificBaseTypeRef
   #
=
  $ %
typeDef
  & -
.
  - .
BaseType
  . 6
;
  6 7
if
ÃÃ 
(
ÃÃ !
specificBaseTypeRef
ÃÃ #
.
ÃÃ# $&
ContainsGenericParameter
ÃÃ$ <
)
ÃÃ< =
{
ÕÕ 
var
ŒŒ 
genericArgMap
ŒŒ !
=
ŒŒ" #
new
ŒŒ$ '

Dictionary
ŒŒ( 2
<
ŒŒ2 3
string
ŒŒ3 9
,
ŒŒ9 :
TypeReference
ŒŒ; H
>
ŒŒH I
(
ŒŒI J
)
ŒŒJ K
;
ŒŒK L
foreach
–– 
(
–– 
var
–– 
ancestor
–– %
in
––& (
specificTypeRef
––) 8
.
––8 9#
AllNestParentsAndSelf
––9 N
(
––N O
)
––O P
)
––P Q
{
—— 
var
““ ,
specificTypeRefGenericInstance
““ 6
=
““7 8
ancestor
““9 A
as
““B D!
GenericInstanceType
““E X
;
““X Y
if
‘‘ 
(
‘‘ ,
specificTypeRefGenericInstance
‘‘ 6
!=
‘‘7 9
null
‘‘: >
)
‘‘> ?
{
’’ 
for
÷÷ 
(
÷÷ 
int
÷÷  
i
÷÷! "
=
÷÷# $
$num
÷÷% &
;
÷÷& '
i
÷÷( )
<
÷÷* +
typeDef
÷÷, 3
.
÷÷3 4
GenericParameters
÷÷4 E
.
÷÷E F
Count
÷÷F K
;
÷÷K L
i
÷÷M N
++
÷÷N P
)
÷÷P Q
{
◊◊ 
genericArgMap
ÿÿ )
[
ÿÿ) *
typeDef
ÿÿ* 1
.
ÿÿ1 2
GenericParameters
ÿÿ2 C
[
ÿÿC D
i
ÿÿD E
]
ÿÿE F
.
ÿÿF G
Name
ÿÿG K
]
ÿÿK L
=
ÿÿM N,
specificTypeRefGenericInstance
ÿÿO m
.
ÿÿm n
GenericArguments
ÿÿn ~
[
ÿÿ~ 
iÿÿ Ä
]ÿÿÄ Å
;ÿÿÅ Ç
}
ŸŸ 
}
⁄⁄ 
}
€€ !
specificBaseTypeRef
›› #
=
››$ %%
FillInGenericParameters
››& =
(
››= >!
specificBaseTypeRef
››> Q
,
››Q R
genericArgMap
››S `
)
››` a
;
››a b
}
ﬁﬁ 
return
‡‡ !
specificBaseTypeRef
‡‡ &
;
‡‡& '
}
·· 	
public
„„ 
static
„„ 
TypeReference
„„ #%
FillInGenericParameters
„„$ ;
(
„„; <
TypeReference
‰‰ 
type
‰‰ 
,
‰‰ 

Dictionary
‰‰  *
<
‰‰* +
string
‰‰+ 1
,
‰‰1 2
TypeReference
‰‰3 @
>
‰‰@ A
genericArgMap
‰‰B O
)
‰‰O P
{
ÂÂ 	
var
ÊÊ 
genericType
ÊÊ 
=
ÊÊ 
type
ÊÊ "
as
ÊÊ# %!
GenericInstanceType
ÊÊ& 9
;
ÊÊ9 :
Assert
ÁÁ 
.
ÁÁ 
	IsNotNull
ÁÁ 
(
ÁÁ 
genericType
ÁÁ (
)
ÁÁ( )
;
ÁÁ) *
var
ÈÈ 
genericTypeClone
ÈÈ  
=
ÈÈ! "
new
ÈÈ# &!
GenericInstanceType
ÈÈ' :
(
ÈÈ: ;
type
ÈÈ; ?
.
ÈÈ? @
Resolve
ÈÈ@ G
(
ÈÈG H
)
ÈÈH I
)
ÈÈI J
;
ÈÈJ K
for
ÎÎ 
(
ÎÎ 
int
ÎÎ 
i
ÎÎ 
=
ÎÎ 
$num
ÎÎ 
;
ÎÎ 
i
ÎÎ 
<
ÎÎ 
genericType
ÎÎ  +
.
ÎÎ+ ,
GenericArguments
ÎÎ, <
.
ÎÎ< =
Count
ÎÎ= B
;
ÎÎB C
i
ÎÎD E
++
ÎÎE G
)
ÎÎG H
{
ÏÏ 
var
ÌÌ 
arg
ÌÌ 
=
ÌÌ 
genericType
ÌÌ %
.
ÌÌ% &
GenericArguments
ÌÌ& 6
[
ÌÌ6 7
i
ÌÌ7 8
]
ÌÌ8 9
;
ÌÌ9 :
if
ÔÔ 
(
ÔÔ 
arg
ÔÔ 
.
ÔÔ  
IsGenericParameter
ÔÔ *
)
ÔÔ* +
{
 
Assert
ÒÒ 
.
ÒÒ 
That
ÒÒ 
(
ÒÒ  
genericArgMap
ÒÒ  -
.
ÒÒ- .
ContainsKey
ÒÒ. 9
(
ÒÒ9 :
arg
ÒÒ: =
.
ÒÒ= >
Name
ÒÒ> B
)
ÒÒB C
,
ÒÒC D
$str
ÒÒE n
,
ÒÒn o
arg
ÒÒp s
.
ÒÒs t
Name
ÒÒt x
,
ÒÒx y
type
ÒÒz ~
.
ÒÒ~ 
FullNameÒÒ á
)ÒÒá à
;ÒÒà â
genericTypeClone
ÛÛ $
.
ÛÛ$ %
GenericArguments
ÛÛ% 5
.
ÛÛ5 6
Add
ÛÛ6 9
(
ÛÛ9 :
genericArgMap
ÛÛ: G
[
ÛÛG H
arg
ÛÛH K
.
ÛÛK L
Name
ÛÛL P
]
ÛÛP Q
)
ÛÛQ R
;
ÛÛR S
}
ÙÙ 
else
ıı 
{
ˆˆ 
genericTypeClone
˜˜ $
.
˜˜$ %
GenericArguments
˜˜% 5
.
˜˜5 6
Add
˜˜6 9
(
˜˜9 :
arg
˜˜: =
)
˜˜= >
;
˜˜> ?
}
¯¯ 
}
˘˘ 
return
˚˚ 
genericTypeClone
˚˚ #
;
˚˚# $
}
¸¸ 	
}
˝˝ 
}˛˛ Ã6
C:\Users\–ö–ª–∏–º–Ω—é–∫\tring\App\Assets\Plugins\Zenject\OptionalExtras\ReflectionBaking\Unity\ReflectionBakingBuildObserver.cs
	namespace 	
Zenject
 
. 
ReflectionBaking "
{ 
public 

static 
class )
ReflectionBakingBuildObserver 5
{ 
[ 	"
InitializeOnLoadMethod	 
]  
public 
static 
void 

Initialize %
(% &
)& '
{ 	
CompilationPipeline 
.  '
assemblyCompilationFinished  ;
+=< >
OnAssemblyCompiled? Q
;Q R
} 	
static 
void 
OnAssemblyCompiled &
(& '
string' -
assemblyAssetPath. ?
,? @
CompilerMessageA P
[P Q
]Q R
messagesS [
)[ \
{ 	
if 
( 
Application 
. 
isEditor $
&&% '
!( )
BuildPipeline) 6
.6 7
isBuildingPlayer7 G
)G H
{ 
return 
; 
} 
if 
( #
EditorUserBuildSettings '
.' (
activeBuildTarget( 9
==: <
BuildTarget= H
.H I
	WSAPlayerI R
)R S
{   
Log!! 
.!! 
Warn!! 
(!! 
$str!! s
)!!s t
;!!t u
}"" 
else## 
{$$ 
TryWeaveAssembly%%  
(%%  !
assemblyAssetPath%%! 2
)%%2 3
;%%3 4
}&& 
}'' 	
static)) 
void)) 
TryWeaveAssembly)) $
())$ %
string))% +
assemblyAssetPath)), =
)))= >
{** 	
var++ 
settings++ 
=++ (
ReflectionBakingInternalUtil++ 7
.++7 8)
TryGetEnabledSettingsInstance++8 U
(++U V
)++V W
;++W X
if-- 
(-- 
settings-- 
==-- 
null--  
)--  !
{.. 
return// 
;// 
}00 
if22 
(22 
settings22 
.22 "
AllGeneratedAssemblies22 /
&&220 2
settings223 ;
.22; <
ExcludeAssemblies22< M
.22M N
Contains22N V
(22V W
assemblyAssetPath22W h
)22h i
)22i j
{33 
return44 
;44 
}55 
if77 
(77 
!77 
settings77 
.77 "
AllGeneratedAssemblies77 0
&&771 3
!774 5
settings775 =
.77= >
IncludeAssemblies77> O
.77O P
Contains77P X
(77X Y
assemblyAssetPath77Y j
)77j k
)77k l
{88 
return99 
;99 
}:: 
var<< 
	stopwatch<< 
=<< 
new<< 
	Stopwatch<<  )
(<<) *
)<<* +
;<<+ ,
	stopwatch== 
.== 
Start== 
(== 
)== 
;== 
var?? 
assemblyFullPath??  
=??! "(
ReflectionBakingInternalUtil??# ?
.??? @(
ConvertAssetPathToSystemPath??@ \
(??\ ]
assemblyAssetPath??] n
)??n o
;??o p
varAA 
readerParametersAA  
=AA! "
newAA# &
ReaderParametersAA' 7
{BB 
AssemblyResolverCC  
=CC! "
newCC# &!
UnityAssemblyResolverCC' <
(CC< =
)CC= >
,CC> ?
}FF 
;FF 
varHH 
moduleHH 
=HH 
ModuleDefinitionHH )
.HH) *

ReadModuleHH* 4
(HH4 5
assemblyFullPathHH5 E
,HHE F
readerParametersHHG W
)HHW X
;HHX Y
varJJ 
assemblyRefNamesJJ  
=JJ! "
moduleJJ# )
.JJ) *
AssemblyReferencesJJ* <
.JJ< =
SelectJJ= C
(JJC D
xJJD E
=>JJF H
xJJI J
.JJJ K
NameJJK O
.JJO P
ToLowerJJP W
(JJW X
)JJX Y
)JJY Z
.JJZ [
ToListJJ[ a
(JJa b
)JJb c
;JJc d
ifLL 
(LL 
!LL 
assemblyRefNamesLL !
.LL! "
ContainsLL" *
(LL* +
$strLL+ :
)LL: ;
)LL; <
{MM 
returnPP 
;PP 
}QQ 
varSS 
assemblyNameSS 
=SS 
PathSS #
.SS# $'
GetFileNameWithoutExtensionSS$ ?
(SS? @
assemblyAssetPathSS@ Q
)SSQ R
;SSR S
varTT 
assemblyTT 
=TT 
	AppDomainTT $
.TT$ %
CurrentDomainTT% 2
.TT2 3
GetAssembliesTT3 @
(TT@ A
)TTA B
.UU 
WhereUU 
(UU 
xUU 
=>UU 
xUU 
.UU 
GetNameUU %
(UU% &
)UU& '
.UU' (
NameUU( ,
==UU- /
assemblyNameUU0 <
)UU< =
.UU= >
OnlyOrDefaultUU> K
(UUK L
)UUL M
;UUM N
AssertWW 
.WW 
	IsNotNullWW 
(WW 
assemblyWW %
,WW% &
$strWW' t
,WWt u
assemblyName	WWv Ç
)
WWÇ É
;
WWÉ Ñ
intYY 
numTypesChangedYY 
=YY  !(
ReflectionBakingModuleEditorYY" >
.YY> ?
WeaveAssemblyYY? L
(YYL M
moduleZZ 
,ZZ 
assemblyZZ  
,ZZ  !
settingsZZ" *
.ZZ* +
NamespacePatternsZZ+ <
)ZZ< =
;ZZ= >
if\\ 
(\\ 
numTypesChanged\\ 
>\\  !
$num\\" #
)\\# $
{]] 
var^^ 
writerParams^^  
=^^! "
new^^# &
WriterParameters^^' 7
(^^7 8
)^^8 9
{__ 
}bb 
;bb 
moduledd 
.dd 
Writedd 
(dd 
assemblyFullPathdd -
,dd- .
writerParamsdd/ ;
)dd; <
;dd< =
Debugff 
.ff 
Logff 
(ff 
$strff k
.gg 
Fmtgg 
(gg 
numTypesChangedgg (
,gg( )
Pathgg* .
.gg. /
GetFileNamegg/ :
(gg: ;
assemblyAssetPathgg; L
)ggL M
,ggM N
	stopwatchggO X
.ggX Y
ElapsedggY `
.gg` a
TotalSecondsgga m
)ggm n
)ggn o
;ggo p
}hh 
}ii 	
}jj 
}kk ˆ
ÅC:\Users\–ö–ª–∏–º–Ω—é–∫\tring\App\Assets\Plugins\Zenject\OptionalExtras\ReflectionBaking\Unity\ZenjectReflectionBakingSettings.cs
	namespace 	
Zenject
 
. 
ReflectionBaking "
{ 
public 

class +
ZenjectReflectionBakingSettings 0
:1 2
ScriptableObject3 C
{ 
[ 	
SerializeField	 
] 
bool		 
_isEnabledInBuilds		 
=		  !
true		" &
;		& '
[ 	
SerializeField	 
] 
bool 
_isEnabledInEditor 
=  !
false" '
;' (
[ 	
SerializeField	 
] 
bool #
_allGeneratedAssemblies $
=% &
true' +
;+ ,
[ 	
SerializeField	 
] 
List 
< 
string 
> 
_includeAssemblies '
=( )
null* .
;. /
[ 	
SerializeField	 
] 
List 
< 
string 
> 
_excludeAssemblies '
=( )
null* .
;. /
[ 	
SerializeField	 
] 
List 
< 
string 
> 
_namespacePatterns '
=( )
null* .
;. /
public 
List 
< 
string 
> 
NamespacePatterns -
{ 	
get 
{ 
return 
_namespacePatterns +
;+ ,
}- .
} 	
public 
List 
< 
string 
> 
IncludeAssemblies -
{   	
get!! 
{!! 
return!! 
_includeAssemblies!! +
;!!+ ,
}!!- .
}"" 	
public$$ 
List$$ 
<$$ 
string$$ 
>$$ 
ExcludeAssemblies$$ -
{%% 	
get&& 
{&& 
return&& 
_excludeAssemblies&& +
;&&+ ,
}&&- .
}'' 	
public)) 
bool)) 
IsEnabledInEditor)) %
{** 	
get++ 
{++ 
return++ 
_isEnabledInEditor++ +
;+++ ,
}++- .
},, 	
public.. 
bool.. 
IsEnabledInBuilds.. %
{// 	
get00 
{00 
return00 
_isEnabledInBuilds00 +
;00+ ,
}00- .
}11 	
public33 
bool33 "
AllGeneratedAssemblies33 *
{44 	
get55 
{55 
return55 #
_allGeneratedAssemblies55 0
;550 1
}552 3
}66 	
}77 
}88 